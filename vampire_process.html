<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vampire Process Visualization</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #1e1e1e, #2d2d2d);
            color: white;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            text-align: center;
        }
        
        h1 {
            color: #ff4444;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            margin-bottom: 10px;
        }
        
        .subtitle {
            color: #cccccc;
            margin-bottom: 30px;
            font-size: 16px;
        }
        
        .canvas-container {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }
        
        canvas {
            border: 2px solid #333;
            border-radius: 8px;
            background: #f8f8f8;
            cursor: none; /* Hide default cursor */
        }
        
        .custom-cursor {
            position: absolute;
            width: 30px;
            height: 30px;
            pointer-events: none;
            z-index: 1000;
            transition: all 0.1s ease;
        }
        
        .butterfly-cursor {
            position: relative;
            width: 100%;
            height: 100%;
            transform-origin: center;
            animation: butterfly-flap 0.3s ease-in-out infinite alternate;
        }
        
        .butterfly-wing {
            position: absolute;
            width: 15px;
            height: 20px;
            border-radius: 50% 10% 50% 10%;
            background: linear-gradient(45deg, #ff4444, #ff6666, #cc0000);
            box-shadow: 0 0 8px rgba(255, 68, 68, 0.6);
        }
        
        .butterfly-wing.left {
            left: 0;
            top: 0;
            transform: rotate(-30deg);
        }
        
        .butterfly-wing.right {
            right: 0;
            top: 0;
            transform: rotate(30deg);
        }
        
        .butterfly-body {
            position: absolute;
            left: 50%;
            top: 50%;
            width: 3px;
            height: 25px;
            background: linear-gradient(to bottom, #333, #666);
            transform: translate(-50%, -50%);
            border-radius: 2px;
        }
        
        @keyframes butterfly-flap {
            0% { transform: rotate(-5deg); }
            100% { transform: rotate(5deg); }
        }
        
        .cursor-trail {
            position: absolute;
            width: 4px;
            height: 4px;
            background: rgba(255, 68, 68, 0.6);
            border-radius: 50%;
            pointer-events: none;
            z-index: 999;
        }
        
        .controls {
            margin: 20px 0;
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        button {
            background: linear-gradient(45deg, #ff4444, #cc0000);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(255, 68, 68, 0.3);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 68, 68, 0.4);
        }
        
        button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .stat-card {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #ff4444;
        }
        
        .stat-label {
            font-size: 14px;
            color: #cccccc;
            margin-top: 5px;
        }
        
        .info {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: left;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .info h3 {
            color: #ff4444;
            margin-top: 0;
        }
        
        .info ul {
            margin: 10px 0;
            padding-left: 20px;
        }
        
        .info li {
            margin: 5px 0;
            color: #cccccc;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸ§› Vampire Process Visualization</h1>
        <p class="subtitle">Real-time visualization of Vampire process behavior</p>
        
        <div class="canvas-container">
            <canvas id="vampireCanvas" width="1000" height="600"></canvas>
            <div id="customCursor" class="custom-cursor">
                <div class="butterfly-cursor">
                    <div class="butterfly-wing left"></div>
                    <div class="butterfly-wing right"></div>
                    <div class="butterfly-body"></div>
                </div>
            </div>
        </div>
        
        <div class="controls">
            <button id="startBtn" onclick="startVampireProcess()">Start Vampire Process</button>
            <button id="stopBtn" onclick="stopVampireProcess()" disabled>Stop Process</button>
            <button id="clearBtn" onclick="clearVisualization()">Clear</button>
            <button id="clearDrawingBtn" onclick="clearDrawing()">Clear Drawing</button>
            <button id="snapshotBtn" onclick="takeSnapshot()">Take Snapshot</button>
            <button id="followBtn" onclick="toggleMouseFollowing()">Toggle Mouse Following</button>
            <button id="bresenhamBtn" onclick="toggleBresenhamCircles()">Toggle Bresenham Circles</button>
            <button id="sineBtn" onclick="toggleSineWaves()">Toggle Sine Waves</button>
            <button id="audioBtn" onclick="toggleAudio()">Enable Audio</button>
            <label style="display:flex;align-items:center;gap:6px;color:#ccc;">
                Volume
                <input id="audioVol" type="range" min="0" max="1" step="0.01" value="0.12" onchange="setAudioVolume(this.value)" />
            </label>
        </div>
        
        <div class="controls">
            <h3 style="color: #ff4444; margin: 10px 0;">Chaos Math Components</h3>
            <button id="lorenzAttractorBtn" onclick="toggleChaosComponent('lorenzAttractor')">Lorenz Attractor</button>
            <button id="mandelbrotFieldBtn" onclick="toggleChaosComponent('mandelbrotField')">Mandelbrot Field</button>
            <button id="chaoticMovementBtn" onclick="toggleChaosComponent('chaoticMovement')">Chaotic Movement</button>
            <button id="fractalBranchesBtn" onclick="toggleChaosComponent('fractalBranches')">Fractal Branches</button>
        </div>
        
        <div class="controls">
            <h3 style="color: #ff4444; margin: 10px 0;">Ï€ Calculation Methods</h3>
            <button id="calculatePiBtn" onclick="calculatePi()">Calculate Ï€</button>
            <button id="clearPiBtn" onclick="clearPiCalculations()">Clear Results</button>
            <input type="range" id="piIterations" min="100" max="10000" value="1000" onchange="updatePiIterations()">
            <label for="piIterations">Iterations: <span id="iterationCount">1000</span></label>
        </div>
        
        <div class="controls">
            <h3 style="color: #ff4444; margin: 10px 0;">Rapid Convergence Ï€</h3>
            <button id="calculateRapidBtn" onclick="calculateRapidPi()">Calculate Rapid Ï€</button>
            <button id="clearRapidBtn" onclick="clearRapidPi()">Clear Rapid Results</button>
        </div>
        
        <div class="controls">
            <h3 style="color: #ff4444; margin: 10px 0;">Infinite Ï€ Calculation</h3>
            <button id="startInfiniteBtn" onclick="startInfinitePi()">Start Infinite Ï€</button>
            <button id="stopInfiniteBtn" onclick="stopInfinitePi()" disabled>Stop Infinite Ï€</button>
            <button id="resetInfiniteBtn" onclick="resetInfinitePi()">Reset</button>
        </div>
        
        <div class="controls">
            <h3 style="color: #ff4444; margin: 10px 0;">Collatz Conjecture</h3>
            <button id="calculateCollatzBtn" onclick="calculateCollatz()">Calculate Collatz</button>
            <button id="calculateCollatzChaosBtn" onclick="calculateCollatzChaos()">Collatz Chaos</button>
            <button id="calculateCollatzStatsBtn" onclick="calculateCollatzStats()">Collatz Statistics</button>
            <button id="calculateCollatzTreeBtn" onclick="calculateCollatzTree()">Collatz Tree</button>
            <button id="calculateCollatzLorenzBtn" onclick="calculateCollatzLorenz()">Collatz-Lorenz</button>
            <input type="number" id="collatzStartValue" value="27" min="1" max="1000000">
            <label for="collatzStartValue">Start Value</label>
        </div>
        
        <div class="controls">
            <h3 style="color: #ff4444; margin: 10px 0;">Vampire Process Mode</h3>
            <button id="hybridPiCollatzBtn" onclick="toggleHybridPiCollatz()">Enable Hybrid Ï€-Collatz</button>
            <button id="piVampireBtn" onclick="togglePiVampire()">Ï€ Vampire</button>
            <button id="collatzVampireBtn" onclick="toggleCollatzVampire()">Collatz Vampire</button>
            <button id="traditionalVampireBtn" onclick="toggleTraditionalVampire()">Traditional Vampire</button>
        </div>
        
        <div class="stats">
            <div class="stat-card">
                <div class="stat-value" id="activeProcesses">0</div>
                <div class="stat-label">Active Processes</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="totalEvents">0</div>
                <div class="stat-label">Total Events</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="frameCount">0</div>
                <div class="stat-label">Frame Count</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="processDepth">0</div>
                <div class="stat-label">Max Depth</div>
            </div>
        </div>
        
        <div class="stats">
            <h3 style="color: #ff4444; margin: 10px 0; grid-column: 1 / -1;">Ï€ Calculation Results</h3>
            <div class="stat-card">
                <div class="stat-value" id="monteCarloPi">0.000000</div>
                <div class="stat-label">Monte Carlo Ï€</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="buffonPi">0.000000</div>
                <div class="stat-label">Buffon Needle Ï€</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="seriesPi">0.000000</div>
                <div class="stat-label">Infinite Series Ï€</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="goldenPi">0.000000</div>
                <div class="stat-label">Golden Ratio Ï€</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="mandelbrotPi">0.000000</div>
                <div class="stat-label">Mandelbrot Ï€</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="combinedPi">0.000000</div>
                <div class="stat-label">Combined Ï€</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="actualPi">3.141593</div>
                <div class="stat-label">Actual Ï€</div>
            </div>
        </div>
        
        <div class="stats">
            <h3 style="color: #ff4444; margin: 10px 0; grid-column: 1 / -1;">Rapid Convergence Ï€ Methods</h3>
            <div class="stat-card">
                <div class="stat-value" id="ramanujanPi">0.000000</div>
                <div class="stat-label">Ramanujan Ï€</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="chudnovskyPi">0.000000</div>
                <div class="stat-label">Chudnovsky Ï€</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="machinPi">0.000000</div>
                <div class="stat-label">Machin Ï€</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="gaussLegendrePi">0.000000</div>
                <div class="stat-label">Gauss-Legendre Ï€</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="borweinQuarticPi">0.000000</div>
                <div class="stat-label">Borwein Quartic Ï€</div>
            </div>
        </div>
        
        <div class="stats">
            <h3 style="color: #ff4444; margin: 10px 0; grid-column: 1 / -1;">Collatz Conjecture Statistics</h3>
            <div class="stat-card">
                <div class="stat-value" id="collatzStartValue">27</div>
                <div class="stat-label">Start Value</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="collatzSteps">0</div>
                <div class="stat-label">Steps to 1</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="collatzMaxValue">0</div>
                <div class="stat-label">Max Value</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="collatzTotalSequences">0</div>
                <div class="stat-label">Total Sequences</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="collatzMaxSteps">0</div>
                <div class="stat-label">Max Steps</div>
            </div>
        </div>
        
        <div class="info">
            <h3>About the Vampire Process</h3>
            <p>This visualization shows the behavior of vampire.cpp:</p>
            <ul>
                <li><strong>Process Spawning:</strong> Each process spawns a child and immediately dies</li>
                <li><strong>Continuous Cycle:</strong> The child becomes the new parent, continuing the cycle</li>
                <li><strong>Real-time Visualization:</strong> Red circles represent active processes</li>
                <li><strong>Process Relationships:</strong> Arrows show parent-child connections</li>
                <li><strong>Live Statistics:</strong> Monitor active processes, events, and depth</li>
            </ul>
        </div>
    </div>

    <script>
        // Chaos Mathematics Class - Divided into 4 Parts
        class ChaosMath {
            constructor() {
                this.phi = 1.618033988749895; // Golden ratio
                this.enabledComponents = {
                    lorenzAttractor: true,
                    mandelbrotField: true,
                    chaoticMovement: true,
                    fractalBranches: true
                };
            }
            
            // Part 1: Lorenz Attractor Mathematics
            calculateLorenzAttractor(parent, child, time, steps, scale, sigma, rho, beta, offset) {
                const halfSteps = Math.floor(steps / 2);
                const points = [];
                
                // Different initial conditions using golden ratio
                let x = 1 + offset * this.phi * 0.1;
                let y = 1 + offset * this.phi * 0.05;
                let z = 1 + offset * this.phi * 0.02;
                
                // First half (upper wing)
                for (let i = 0; i < halfSteps; i++) {
                    // Lorenz equations with golden ratio variations
                    const dx = (sigma + offset * this.phi * 0.1) * (y - x);
                    const dy = x * (rho + offset * this.phi * 0.2 - z) - (y + offset * this.phi * 0.1);
                    const dz = x * y - (beta + offset * this.phi * 0.01) * z;
                    
                    x += dx * (0.01 + offset * this.phi * 0.001);
                    y += dy * (0.01 + offset * this.phi * 0.001);
                    z += dz * (0.01 + offset * this.phi * 0.001);
                    
                    // Map to screen coordinates with golden ratio scaling
                    const progress = i / steps;
                    const baseX = parent.x + (child.x - parent.x) * progress;
                    const baseY = parent.y + (child.y - parent.y) * progress;
                    
                    // Add golden ratio phase offset for each attractor
                    const phaseOffset = offset * Math.PI / this.phi;
                    const goldenScale = scale * (1 + offset * (this.phi - 1) * 0.1);
                    const screenX = baseX + x * goldenScale * Math.sin(time * this.phi + phaseOffset);
                    const screenY = baseY + y * goldenScale * Math.cos(time * this.phi + phaseOffset);
                    
                    points.push({x: screenX, y: screenY, wing: 'upper'});
                }
                
                // Second half (lower wing) - flipped direction
                x = 1 + offset * this.phi * 0.1;
                y = 1 + offset * this.phi * 0.05;
                z = 1 + offset * this.phi * 0.02;
                
                for (let i = halfSteps; i < steps; i++) {
                    // Lorenz equations with golden ratio variations
                    const dx = (sigma + offset * this.phi * 0.1) * (y - x);
                    const dy = x * (rho + offset * this.phi * 0.2 - z) - (y + offset * this.phi * 0.1);
                    const dz = x * y - (beta + offset * this.phi * 0.01) * z;
                    
                    x += dx * (0.01 + offset * this.phi * 0.001);
                    y += dy * (0.01 + offset * this.phi * 0.001);
                    z += dz * (0.01 + offset * this.phi * 0.001);
                    
                    // Map to screen coordinates with flipped direction
                    const progress = i / steps;
                    const baseX = parent.x + (child.x - parent.x) * progress;
                    const baseY = parent.y + (child.y - parent.y) * progress;
                    
                    // Flip the second half - opposite direction
                    const phaseOffset = offset * Math.PI / this.phi;
                    const goldenScale = scale * (1 + offset * (this.phi - 1) * 0.1);
                    const screenX = baseX - x * goldenScale * Math.sin(time * this.phi + phaseOffset);
                    const screenY = baseY - y * goldenScale * Math.cos(time * this.phi + phaseOffset);
                    
                    points.push({x: screenX, y: screenY, wing: 'lower'});
                }
                
                return points;
            }
            
            // Part 2: Mandelbrot Set Mathematics
            calculateMandelbrotField(canvasWidth, canvasHeight, time) {
                const scale = 50;
                const points = [];
                
                for (let x = 0; x < canvasWidth; x += 20) {
                    for (let y = 0; y < canvasHeight; y += 20) {
                        const cx = (x - canvasWidth / 2) / scale;
                        const cy = (y - canvasHeight / 2) / scale;
                        
                        // Simplified Mandelbrot iteration
                        let zx = cx + Math.sin(time) * 0.1;
                        let zy = cy + Math.cos(time) * 0.1;
                        let iterations = 0;
                        const maxIterations = 20;
                        
                        while (zx * zx + zy * zy < 4 && iterations < maxIterations) {
                            const tmp = zx * zx - zy * zy + cx;
                            zy = 2 * zx * zy + cy;
                            zx = tmp;
                            iterations++;
                        }
                        
                        const intensity = iterations / maxIterations;
                        if (intensity > 0.3) {
                            points.push({
                                x: x,
                                y: y,
                                intensity: intensity,
                                iterations: iterations
                            });
                        }
                    }
                }
                
                return points;
            }
            
            // Part 3: Chaotic Movement Mathematics
            calculateChaoticMovement(process, time) {
                const id = process.id;
                
                // Use process ID as seed for consistent but unique movement
                const seed1 = id * 0.1;
                const seed2 = id * 0.15;
                
                // Chaotic butterfly flight pattern
                const chaosX = Math.sin(time * 0.5 + seed1) * 2 + 
                              Math.sin(time * 1.7 + seed2) * 1.5 +
                              Math.sin(time * 3.1 + seed1 * 2) * 0.8;
                              
                const chaosY = Math.cos(time * 0.7 + seed2) * 2 + 
                              Math.cos(time * 1.3 + seed1) * 1.2 +
                              Math.cos(time * 2.9 + seed2 * 1.5) * 0.6;
                
                return {
                    chaosX: chaosX,
                    chaosY: chaosY,
                    seed1: seed1,
                    seed2: seed2
                };
            }
            
            // Part 4: Fractal Branching Mathematics
            calculateFractalBranches(process1, process2, seed, time) {
                const midX = (process1.x + process2.x) / 2;
                const midY = (process1.y + process2.y) / 2;
                const branches = [];
                
                // Generate fractal branch points
                for (let i = 0; i < 3; i++) {
                    const angle = (i * Math.PI * 2 / 3) + time + seed;
                    const length = 30 + Math.sin(time * 2 + seed + i) * 15;
                    
                    const branchX = midX + Math.cos(angle) * length;
                    const branchY = midY + Math.sin(angle) * length;
                    
                    branches.push({
                        startX: midX,
                        startY: midY,
                        endX: branchX,
                        endY: branchY,
                        angle: angle,
                        length: length,
                        subBranches: []
                    });
                    
                    // Recursive smaller branches
                    if (Math.random() > 0.5) {
                        const subAngle = angle + (Math.random() - 0.5) * Math.PI / 2;
                        const subLength = length * 0.6;
                        const subX = branchX + Math.cos(subAngle) * subLength;
                        const subY = branchY + Math.sin(subAngle) * subLength;
                        
                        branches[i].subBranches.push({
                            startX: branchX,
                            startY: branchY,
                            endX: subX,
                            endY: subY,
                            angle: subAngle,
                            length: subLength
                        });
                    }
                }
                
                return branches;
            }
            
            // Secondary Attractor Mathematics
            calculateSecondaryAttractor(parent, child, time, steps, scale, offset) {
                const points = [];
                
                // Different attractor parameters using golden ratio for secondary pattern
                const sigma2 = 12 * this.phi + offset * this.phi * 0.5;
                const rho2 = 26 / this.phi + offset * this.phi * 0.8;
                const beta2 = 2.5 * this.phi + offset * this.phi * 0.1;
                
                let x = 0.5 + offset * this.phi * 0.2;
                let y = 0.5 + offset * this.phi * 0.15;
                let z = 0.5 + offset * this.phi * 0.1;
                
                for (let i = 0; i < steps; i++) {
                    // Modified Lorenz equations for secondary attractor with golden ratio
                    const dx = sigma2 * (y - x);
                    const dy = x * (rho2 - z) - y;
                    const dz = x * y - beta2 * z;
                    
                    x += dx * (0.008 * this.phi);
                    y += dy * (0.008 * this.phi);
                    z += dz * (0.008 * this.phi);
                    
                    // Map to screen coordinates with golden ratio scaling
                    const progress = i / steps;
                    const baseX = parent.x + (child.x - parent.x) * progress;
                    const baseY = parent.y + (child.y - parent.y) * progress;
                    
                    // Different phase and scaling using golden ratio for secondary attractor
                    const phaseOffset = offset * Math.PI / this.phi + Math.PI / this.phi;
                    const secondaryScale = scale * (1 / this.phi); // Golden ratio inverse scaling
                    const screenX = baseX + x * secondaryScale * Math.cos(time * this.phi * this.phi + phaseOffset);
                    const screenY = baseY + y * secondaryScale * Math.sin(time * this.phi * this.phi + phaseOffset);
                    
                    points.push({x: screenX, y: screenY});
                }
                
                return points;
            }
            
            // Control methods for enabling/disabling components
            toggleComponent(componentName) {
                if (this.enabledComponents.hasOwnProperty(componentName)) {
                    this.enabledComponents[componentName] = !this.enabledComponents[componentName];
                }
            }
            
            isComponentEnabled(componentName) {
                return this.enabledComponents[componentName] || false;
            }
            
            // Ï€ Calculation Methods using Chaos Mathematics
            
            // Method 1: Monte Carlo Ï€ using Mandelbrot field
            calculatePiMonteCarlo(iterations = 10000) {
                let pointsInCircle = 0;
                let totalPoints = 0;
                
                for (let i = 0; i < iterations; i++) {
                    // Generate random points in unit square
                    const x = Math.random() * 2 - 1; // -1 to 1
                    const y = Math.random() * 2 - 1; // -1 to 1
                    
                    // Check if point is inside unit circle
                    if (x * x + y * y <= 1) {
                        pointsInCircle++;
                    }
                    totalPoints++;
                }
                
                // Ï€ â‰ˆ 4 * (points in circle / total points)
                return 4 * (pointsInCircle / totalPoints);
            }
            
            // Method 2: Buffon's Needle using Lorenz attractor
            calculatePiBuffonNeedle(needleLength = 1, lineSpacing = 2, iterations = 10000) {
                let crossings = 0;
                
                for (let i = 0; i < iterations; i++) {
                    // Generate needle position and angle using chaotic system
                    const time = Date.now() * 0.001 + i * 0.01;
                    const x = Math.sin(time * this.phi) * 0.5; // Position
                    const angle = Math.cos(time * this.phi * this.phi) * Math.PI; // Angle
                    
                    // Calculate needle endpoints
                    const x1 = x - (needleLength / 2) * Math.cos(angle);
                    const x2 = x + (needleLength / 2) * Math.cos(angle);
                    
                    // Check for crossings with parallel lines
                    const line1 = Math.floor(x1 / lineSpacing) * lineSpacing;
                    const line2 = Math.floor(x2 / lineSpacing) * lineSpacing;
                    
                    if (line1 !== line2) {
                        crossings++;
                    }
                }
                
                // Ï€ â‰ˆ (2 * needleLength * iterations) / (lineSpacing * crossings)
                return crossings > 0 ? (2 * needleLength * iterations) / (lineSpacing * crossings) : 0;
            }
            
            // Method 3: Infinite Series using Fractal Branching
            calculatePiInfiniteSeries(terms = 1000) {
                let pi = 0;
                
                // Leibniz formula: Ï€/4 = 1 - 1/3 + 1/5 - 1/7 + 1/9 - ...
                for (let i = 0; i < terms; i++) {
                    const term = 1 / (2 * i + 1);
                    pi += (i % 2 === 0) ? term : -term;
                }
                
                return 4 * pi;
            }
            
            // Method 4: Chaos-based Ï€ approximation using golden ratio
            calculatePiGoldenRatio(iterations = 1000) {
                let pi = 0;
                
                for (let i = 0; i < iterations; i++) {
                    // Use golden ratio in chaotic iteration
                    const x = Math.sin(i * this.phi) * this.phi;
                    const y = Math.cos(i * this.phi * this.phi) * this.phi;
                    
                    // Accumulate Ï€ approximation
                    pi += Math.atan2(y, x) / (i + 1);
                }
                
                return Math.abs(pi * 2);
            }
            
            // Method 5: Mandelbrot-based Ï€ calculation
            calculatePiMandelbrot(iterations = 1000) {
                let pi = 0;
                const scale = 100;
                
                for (let i = 0; i < iterations; i++) {
                    const cx = (i % scale) / scale - 0.5;
                    const cy = Math.floor(i / scale) / scale - 0.5;
                    
                    // Simplified Mandelbrot iteration
                    let zx = cx;
                    let zy = cy;
                    let iter = 0;
                    const maxIter = 20;
                    
                    while (zx * zx + zy * zy < 4 && iter < maxIter) {
                        const tmp = zx * zx - zy * zy + cx;
                        zy = 2 * zx * zy + cy;
                        zx = tmp;
                        iter++;
                    }
                    
                    // Use iteration count to approximate Ï€
                    pi += Math.sin(iter * Math.PI / maxIter) / iterations;
                }
                
                return Math.abs(pi * 4);
            }
            
            // Combined Ï€ calculation using all methods
            calculatePiCombined(iterations = 1000) {
                const methods = [
                    this.calculatePiMonteCarlo(iterations),
                    this.calculatePiBuffonNeedle(1, 2, iterations),
                    this.calculatePiInfiniteSeries(Math.min(iterations, 1000)),
                    this.calculatePiGoldenRatio(iterations),
                    this.calculatePiMandelbrot(iterations)
                ];
                
                // Return average of all methods
                const validMethods = methods.filter(m => m > 0 && m < 10);
                return validMethods.length > 0 ? 
                    validMethods.reduce((sum, val) => sum + val, 0) / validMethods.length : 
                    Math.PI;
            }
            
            // Infinite Iteration Ï€ Methods
            
            // Infinite Monte Carlo with convergence tracking
            calculatePiMonteCarloInfinite(currentIterations, previousResult = 0) {
                let pointsInCircle = 0;
                const batchSize = 1000; // Process in batches for performance
                
                for (let i = 0; i < batchSize; i++) {
                    const x = Math.random() * 2 - 1;
                    const y = Math.random() * 2 - 1;
                    if (x * x + y * y <= 1) {
                        pointsInCircle++;
                    }
                }
                
                const newTotal = currentIterations + batchSize;
                const newPointsInCircle = (previousResult * currentIterations / 4) + pointsInCircle;
                return 4 * (newPointsInCircle / newTotal);
            }
            
            // Infinite Buffon's Needle with convergence tracking
            calculatePiBuffonInfinite(currentIterations, previousCrossings = 0, previousResult = 0) {
                const batchSize = 1000;
                let newCrossings = 0;
                const needleLength = 1;
                const lineSpacing = 2;
                
                for (let i = 0; i < batchSize; i++) {
                    const time = Date.now() * 0.001 + i * 0.01;
                    const x = Math.sin(time * this.phi) * 0.5;
                    const angle = Math.cos(time * this.phi * this.phi) * Math.PI;
                    
                    const x1 = x - (needleLength / 2) * Math.cos(angle);
                    const x2 = x + (needleLength / 2) * Math.cos(angle);
                    
                    const line1 = Math.floor(x1 / lineSpacing) * lineSpacing;
                    const line2 = Math.floor(x2 / lineSpacing) * lineSpacing;
                    
                    if (line1 !== line2) {
                        newCrossings++;
                    }
                }
                
                const totalCrossings = previousCrossings + newCrossings;
                const totalIterations = currentIterations + batchSize;
                
                return totalCrossings > 0 ? (2 * needleLength * totalIterations) / (lineSpacing * totalCrossings) : 0;
            }
            
            // Infinite Series with convergence tracking
            calculatePiInfiniteSeriesInfinite(currentTerms, previousSum = 0) {
                const batchSize = 100;
                let sum = previousSum;
                
                for (let i = currentTerms; i < currentTerms + batchSize; i++) {
                    const term = 1 / (2 * i + 1);
                    sum += (i % 2 === 0) ? term : -term;
                }
                
                return 4 * sum;
            }
            
            // Infinite Golden Ratio with convergence tracking
            calculatePiGoldenRatioInfinite(currentIterations, previousSum = 0) {
                const batchSize = 100;
                let sum = previousSum;
                
                for (let i = currentIterations; i < currentIterations + batchSize; i++) {
                    const x = Math.sin(i * this.phi) * this.phi;
                    const y = Math.cos(i * this.phi * this.phi) * this.phi;
                    sum += Math.atan2(y, x) / (i + 1);
                }
                
                return Math.abs(sum * 2);
            }
            
            // Calculate accuracy (how close to actual Ï€)
            calculateAccuracy(calculatedPi) {
                const actualPi = Math.PI;
                const error = Math.abs(calculatedPi - actualPi);
                return Math.max(0, 1 - (error / actualPi)) * 100; // Percentage accuracy
            }
            
            // Rapidly Converging Series Methods
            
            // Ramanujan's rapidly converging series
            calculatePiRamanujan(iterations = 10) {
                let sum = 0;
                const sqrt2 = Math.sqrt(2);
                
                for (let n = 0; n < iterations; n++) {
                    const numerator = this.factorial(4 * n) * (1103 + 26390 * n);
                    const denominator = Math.pow(this.factorial(n), 4) * Math.pow(396, 4 * n);
                    sum += numerator / denominator;
                }
                
                return 1 / (2 * sqrt2 * sum / 9801);
            }
            
            // Chudnovsky algorithm (most rapidly converging)
            calculatePiChudnovsky(iterations = 10) {
                let sum = 0;
                const sqrtC = Math.sqrt(640320);
                
                for (let n = 0; n < iterations; n++) {
                    const numerator = this.factorial(6 * n) * (13591409 + 545140134 * n);
                    const denominator = this.factorial(3 * n) * Math.pow(this.factorial(n), 3) * Math.pow(-640320, 3 * n);
                    sum += numerator / denominator;
                }
                
                return 1 / (12 * sum / sqrtC);
            }
            
            // Machin-like formula (rapid convergence)
            calculatePiMachin(iterations = 20) {
                let sum = 0;
                
                for (let n = 0; n < iterations; n++) {
                    const term1 = Math.pow(-1, n) / (2 * n + 1) * Math.pow(1/5, 2 * n + 1);
                    const term2 = Math.pow(-1, n) / (2 * n + 1) * Math.pow(1/239, 2 * n + 1);
                    sum += 4 * (4 * term1 - term2);
                }
                
                return sum;
            }
            
            // Gauss-Legendre Algorithm (quadratic convergence)
            calculatePiGaussLegendre(iterations = 10) {
                let a = 1;
                let b = 1 / Math.sqrt(2);
                let t = 1/4;
                let p = 1;
                
                for (let i = 0; i < iterations; i++) {
                    const aNext = (a + b) / 2;
                    const bNext = Math.sqrt(a * b);
                    const tNext = t - p * Math.pow(a - aNext, 2);
                    const pNext = 2 * p;
                    
                    a = aNext;
                    b = bNext;
                    t = tNext;
                    p = pNext;
                }
                
                return Math.pow(a + b, 2) / (4 * t);
            }
            
            // Borwein's quartic algorithm (quartic convergence)
            calculatePiBorweinQuartic(iterations = 10) {
                let y = Math.sqrt(2) - 1;
                let a = 6 - 4 * Math.sqrt(2);
                let pi = 1 / a;
                
                for (let i = 0; i < iterations; i++) {
                    const y4 = Math.pow(y, 4);
                    const yNext = (1 - Math.pow(1 - y4, 1/4)) / (1 + Math.pow(1 - y4, 1/4));
                    const aNext = a * Math.pow(1 + yNext, 4) - Math.pow(2, 2 * i + 3) * yNext * (1 + yNext + Math.pow(yNext, 2));
                    
                    y = yNext;
                    a = aNext;
                    pi = 1 / a;
                }
                
                return pi;
            }
            
            // Helper function for factorial calculation
            factorial(n) {
                if (n < 0) return 0;
                if (n === 0 || n === 1) return 1;
                
                let result = 1;
                for (let i = 2; i <= n; i++) {
                    result *= i;
                }
                return result;
            }
            
            // Infinite versions of rapid convergence methods
            
            // Infinite Ramanujan series
            calculatePiRamanujanInfinite(currentIterations, previousSum = 0) {
                const batchSize = 1; // Process one term at a time for precision
                let sum = previousSum;
                const sqrt2 = Math.sqrt(2);
                
                for (let n = currentIterations; n < currentIterations + batchSize; n++) {
                    const numerator = this.factorial(4 * n) * (1103 + 26390 * n);
                    const denominator = Math.pow(this.factorial(n), 4) * Math.pow(396, 4 * n);
                    sum += numerator / denominator;
                }
                
                return 1 / (2 * sqrt2 * sum / 9801);
            }
            
            // Infinite Chudnovsky series
            calculatePiChudnovskyInfinite(currentIterations, previousSum = 0) {
                const batchSize = 1; // Process one term at a time for precision
                let sum = previousSum;
                const sqrtC = Math.sqrt(640320);
                
                for (let n = currentIterations; n < currentIterations + batchSize; n++) {
                    const numerator = this.factorial(6 * n) * (13591409 + 545140134 * n);
                    const denominator = this.factorial(3 * n) * Math.pow(this.factorial(n), 3) * Math.pow(-640320, 3 * n);
                    sum += numerator / denominator;
                }
                
                return 1 / (12 * sum / sqrtC);
            }
            
            // Infinite Gauss-Legendre
            calculatePiGaussLegendreInfinite(currentIterations, previousState = {a: 1, b: 1/Math.sqrt(2), t: 1/4, p: 1}) {
                const batchSize = 1; // One iteration at a time
                let {a, b, t, p} = previousState;
                
                for (let i = 0; i < batchSize; i++) {
                    const aNext = (a + b) / 2;
                    const bNext = Math.sqrt(a * b);
                    const tNext = t - p * Math.pow(a - aNext, 2);
                    const pNext = 2 * p;
                    
                    a = aNext;
                    b = bNext;
                    t = tNext;
                    p = pNext;
                }
                
                return {
                    pi: Math.pow(a + b, 2) / (4 * t),
                    state: {a, b, t, p}
                };
            }
            
            // Collatz Conjecture Methods
            
            // Basic Collatz sequence calculation
            calculateCollatzSequence(startValue, maxSteps = 1000) {
                const sequence = [startValue];
                let current = startValue;
                let steps = 0;
                
                while (current !== 1 && steps < maxSteps) {
                    if (current % 2 === 0) {
                        current = current / 2;
                    } else {
                        current = 3 * current + 1;
                    }
                    sequence.push(current);
                    steps++;
                }
                
                return {
                    sequence: sequence,
                    steps: steps,
                    reachedOne: current === 1,
                    maxValue: Math.max(...sequence),
                    finalValue: current
                };
            }
            
            // Collatz sequence with chaos visualization
            calculateCollatzChaos(startValue, maxSteps = 1000) {
                const sequence = [startValue];
                const chaosPoints = [];
                let current = startValue;
                let steps = 0;
                
                // Use golden ratio for chaotic positioning
                const phi = this.phi;
                let angle = 0;
                let radius = 50;
                
                while (current !== 1 && steps < maxSteps) {
                    // Add chaos to the sequence visualization
                    const chaosX = Math.sin(angle) * radius;
                    const chaosY = Math.cos(angle) * radius;
                    
                    chaosPoints.push({
                        x: chaosX,
                        y: chaosY,
                        value: current,
                        step: steps,
                        angle: angle,
                        radius: radius
                    });
                    
                    // Collatz step
                    if (current % 2 === 0) {
                        current = current / 2;
                        angle += Math.PI / phi; // Golden ratio angle increment
                        radius *= 0.98; // Slight contraction
                    } else {
                        current = 3 * current + 1;
                        angle += Math.PI * phi; // Larger angle increment for odd
                        radius *= 1.02; // Slight expansion
                    }
                    
                    sequence.push(current);
                    steps++;
                }
                
                return {
                    sequence: sequence,
                    chaosPoints: chaosPoints,
                    steps: steps,
                    reachedOne: current === 1,
                    maxValue: Math.max(...sequence),
                    finalValue: current
                };
            }
            
            // Collatz tree structure (reverse Collatz)
            calculateCollatzTree(maxDepth = 10, maxNodes = 1000) {
                const tree = new Map();
                const visited = new Set();
                const queue = [{value: 1, depth: 0, parent: null}];
                let nodeCount = 0;
                
                while (queue.length > 0 && nodeCount < maxNodes) {
                    const node = queue.shift();
                    const value = node.value;
                    const depth = node.depth;
                    
                    if (visited.has(value) || depth > maxDepth) continue;
                    
                    visited.add(value);
                    nodeCount++;
                    
                    // Find predecessors (reverse Collatz)
                    const predecessors = [];
                    
                    // Even predecessor: 2 * value
                    predecessors.push(2 * value);
                    
                    // Odd predecessor: (value - 1) / 3 (if valid)
                    if ((value - 1) % 3 === 0 && value > 1) {
                        const oddPredecessor = (value - 1) / 3;
                        if (oddPredecessor > 0 && oddPredecessor % 2 === 1) {
                            predecessors.push(oddPredecessor);
                        }
                    }
                    
                    tree.set(value, {
                        value: value,
                        depth: depth,
                        parent: node.parent,
                        predecessors: predecessors,
                        children: []
                    });
                    
                    // Add predecessors to queue
                    for (const pred of predecessors) {
                        if (!visited.has(pred)) {
                            queue.push({value: pred, depth: depth + 1, parent: value});
                        }
                    }
                }
                
                return {
                    tree: tree,
                    maxDepth: maxDepth,
                    nodeCount: nodeCount,
                    rootValue: 1
                };
            }
            
            // Collatz statistics and analysis
            calculateCollatzStatistics(startRange = 1, endRange = 1000) {
                const statistics = {
                    totalNumbers: endRange - startRange + 1,
                    sequences: [],
                    maxSteps: 0,
                    maxValue: 0,
                    averageSteps: 0,
                    stepDistribution: new Map(),
                    valueDistribution: new Map(),
                    convergenceTime: new Map()
                };
                
                let totalSteps = 0;
                
                for (let i = startRange; i <= endRange; i++) {
                    const result = this.calculateCollatzSequence(i, 10000);
                    statistics.sequences.push(result);
                    
                    // Update statistics
                    statistics.maxSteps = Math.max(statistics.maxSteps, result.steps);
                    statistics.maxValue = Math.max(statistics.maxValue, result.maxValue);
                    totalSteps += result.steps;
                    
                    // Step distribution
                    const stepKey = Math.floor(result.steps / 10) * 10;
                    statistics.stepDistribution.set(stepKey, (statistics.stepDistribution.get(stepKey) || 0) + 1);
                    
                    // Value distribution
                    const valueKey = Math.floor(result.maxValue / 100) * 100;
                    statistics.valueDistribution.set(valueKey, (statistics.valueDistribution.get(valueKey) || 0) + 1);
                    
                    // Convergence time
                    const convergenceKey = Math.floor(result.steps / 50) * 50;
                    statistics.convergenceTime.set(convergenceKey, (statistics.convergenceTime.get(convergenceKey) || 0) + 1);
                }
                
                statistics.averageSteps = totalSteps / statistics.totalNumbers;
                
                return statistics;
            }
            
            // Collatz-Lorenz hybrid (combining Collatz with Lorenz attractor)
            calculateCollatzLorenz(startValue, maxSteps = 1000) {
                const sequence = this.calculateCollatzSequence(startValue, maxSteps);
                const lorenzPoints = [];
                
                // Use Collatz sequence to drive Lorenz parameters
                let x = 1, y = 1, z = 1;
                const dt = 0.01;
                
                for (let i = 0; i < sequence.sequence.length; i++) {
                    const collatzValue = sequence.sequence[i];
                    
                    // Use Collatz value to modulate Lorenz parameters
                    const sigma = 10 + (collatzValue % 10);
                    const rho = 28 + (collatzValue % 20);
                    const beta = 8/3 + (collatzValue % 5) / 10;
                    
                    // Lorenz equations
                    const dx = sigma * (y - x);
                    const dy = x * (rho - z) - y;
                    const dz = x * y - beta * z;
                    
                    x += dx * dt;
                    y += dy * dt;
                    z += dz * dt;
                    
                    lorenzPoints.push({
                        x: x * 20,
                        y: y * 20,
                        z: z * 20,
                        collatzValue: collatzValue,
                        step: i,
                        sigma: sigma,
                        rho: rho,
                        beta: beta
                    });
                }
                
                return {
                    collatzSequence: sequence,
                    lorenzPoints: lorenzPoints,
                    hybridData: {
                        maxCollatzValue: sequence.maxValue,
                        totalSteps: sequence.steps,
                        lorenzPoints: lorenzPoints.length
                    }
                };
            }
        }

        class VampireProcessVisualizer {
            constructor() {
                this.canvas = document.getElementById('vampireCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.customCursor = document.getElementById('customCursor');
                this.isRunning = false;
                this.frameCount = 0;
                this.processes = new Map();
                this.events = [];
                this.maxDepth = 0;
                this.animationId = null;
                
                // Process tracking
                this.processCounter = 0;
                this.activeProcesses = new Set();
                
                // Mouse following
                this.cursorTrails = [];
                this.maxTrails = 20;
                this.currentTargetProcess = null;
                this.cursorPosition = { x: 0, y: 0 };
                this.targetPosition = { x: 0, y: 0 };
                this.mouseFollowingEnabled = true;
                
                // Drawing functionality
                this.isDrawing = false;
                this.drawingPath = [];
                this.lastMousePos = { x: 0, y: 0 };
                
                // Bresenham circle settings
                this.bresenhamCirclesEnabled = false;
                this.circleRadius = 8;
                this.circleSpacing = 20;
                
                // Sine wave settings
                this.sineWavesEnabled = true;
                this.sineBaseHz = 1.0; // base temporal frequency in Hz
                this.sineAmplitudeBase = 8; // base pixel amplitude
                this.sineSpatialCyclesBase = 1.5; // base cycles per segment

                // Audio synthesis (Web Audio) driven by sine segments
                this.audioEnabled = false;
                this.audioContext = null;
                this.masterGain = null;
                this.audioVolume = 0.12; // 0..1
                this.sineVoices = []; // [{osc, gain}]
                this.maxSineVoices = 24;
                
                // Initialize Chaos Mathematics
                this.chaosMath = new ChaosMath();
                
                // Ï€ Calculation tracking
                this.piCalculations = {
                    monteCarlo: 0,
                    buffonNeedle: 0,
                    infiniteSeries: 0,
                    goldenRatio: 0,
                    mandelbrot: 0,
                    ramanujan: 0,
                    chudnovsky: 0,
                    machin: 0,
                    gaussLegendre: 0,
                    borweinQuartic: 0,
                    combined: 0,
                    actualPi: Math.PI,
                    iterations: 1000,
                    isCalculating: false,
                    infiniteMode: false,
                    infiniteIterations: 0,
                    convergenceHistory: [],
                    bestAccuracy: 0,
                    animationId: null
                };
                
                // Collatz Conjecture tracking
                this.collatzCalculations = {
                    currentSequence: [],
                    currentStartValue: 1,
                    maxSteps: 0,
                    maxValue: 0,
                    totalSequences: 0,
                    isCalculating: false,
                    statistics: null,
                    tree: null,
                    chaosPoints: [],
                    lorenzHybrid: null,
                    animationId: null
                };
                
                // Vampire Process Mode
                this.collatzVampireMode = false; // Collatz-driven vampire processes
                this.piVampireMode = true; // Ï€-solving vampire processes (default)
                this.hybridPiCollatzMode = false; // Combined Ï€ and Collatz vampire processes
                
                // Visual settings
                this.canvasWidth = 1000;
                this.canvasHeight = 600;
                this.processRadius = 15;
                this.colors = {
                    active: '#ff4444',
                    spawning: '#ff6666',
                    dying: '#ffaaaa'
                };
                
                this.setupCanvas();
                this.setupMouseFollowing();
                this.startAnimation();
            }
            
            setupCanvas() {
                this.canvas.width = this.canvasWidth;
                this.canvas.height = this.canvasHeight;
                this.ctx.font = '12px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
            }
            
            setupMouseFollowing() {
                // Initialize cursor position
                this.cursorPosition.x = this.canvasWidth / 2;
                this.cursorPosition.y = this.canvasHeight / 2;
                this.targetPosition.x = this.cursorPosition.x;
                this.targetPosition.y = this.cursorPosition.y;
                
                // Position custom cursor
                this.updateCustomCursorPosition();
                
                // Add mouse move listener for manual control
                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.cursorPosition.x = e.clientX - rect.left;
                    this.cursorPosition.y = e.clientY - rect.top;
                    this.updateCustomCursorPosition();
                });
                
                // Add mouse event listeners for drawing
                this.canvas.addEventListener('mousedown', (e) => {
                    this.startDrawing(e);
                });
                
                this.canvas.addEventListener('mousemove', (e) => {
                    if (this.isDrawing) {
                        this.drawLine(e);
                    }
                });
                
                this.canvas.addEventListener('mouseup', (e) => {
                    this.stopDrawing();
                });
                
                this.canvas.addEventListener('mouseleave', (e) => {
                    this.stopDrawing();
                });
            }
            
            updateCustomCursorPosition() {
                const canvasRect = this.canvas.getBoundingClientRect();
                this.customCursor.style.left = (canvasRect.left + this.cursorPosition.x - 15) + 'px';
                this.customCursor.style.top = (canvasRect.top + this.cursorPosition.y - 15) + 'px';
            }
            
            startDrawing(e) {
                this.isDrawing = true;
                const rect = this.canvas.getBoundingClientRect();
                this.lastMousePos.x = e.clientX - rect.left;
                this.lastMousePos.y = e.clientY - rect.top;
                this.drawingPath = [this.lastMousePos];
            }
            
            drawLine(e) {
                if (!this.isDrawing) return;
                
                const rect = this.canvas.getBoundingClientRect();
                const currentPos = {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
                
                // Add point to drawing path
                this.drawingPath.push(currentPos);
                
                // Draw line segment immediately
                this.ctx.strokeStyle = 'black';
                this.ctx.lineWidth = 3;
                this.ctx.lineCap = 'round';
                this.ctx.beginPath();
                this.ctx.moveTo(this.lastMousePos.x, this.lastMousePos.y);
                this.ctx.lineTo(currentPos.x, currentPos.y);
                this.ctx.stroke();
                
                this.lastMousePos = currentPos;
            }
            
            stopDrawing() {
                this.isDrawing = false;
            }
            
            updateCursorTarget() {
                if (!this.isRunning || !this.mouseFollowingEnabled) return;
                
                // Find the most recently spawned process
                let newestProcess = null;
                let newestTime = 0;
                
                for (const [id, process] of this.processes) {
                    if (process.spawnTime > newestTime) {
                        newestTime = process.spawnTime;
                        newestProcess = process;
                    }
                }
                
                if (newestProcess) {
                    this.targetPosition.x = newestProcess.x;
                    this.targetPosition.y = newestProcess.y;
                }
            }
            
            updateCursorMovement() {
                // Smooth cursor movement towards target
                const speed = 0.1;
                this.cursorPosition.x += (this.targetPosition.x - this.cursorPosition.x) * speed;
                this.cursorPosition.y += (this.targetPosition.y - this.cursorPosition.y) * speed;
                
                // Add cursor trail
                this.cursorTrails.push({
                    x: this.cursorPosition.x,
                    y: this.cursorPosition.y,
                    life: 1.0
                });
                
                // Update trail life
                this.cursorTrails = this.cursorTrails.filter(trail => {
                    trail.life -= 0.05;
                    return trail.life > 0;
                });
                
                // Limit trail length
                if (this.cursorTrails.length > this.maxTrails) {
                    this.cursorTrails = this.cursorTrails.slice(-this.maxTrails);
                }
                
                this.updateCustomCursorPosition();
            }
            
            startAnimation() {
                const animate = () => {
                    this.update();
                    this.draw();
                    this.animationId = requestAnimationFrame(animate);
                };
                animate();
            }
            
            startVampireProcess() {
                if (this.isRunning) return;
                
                this.isRunning = true;
                this.processCounter = 0;
                this.events = [];
                this.maxDepth = 0;
                
                // Start the first vampire process
                this.spawnVampireProcess(0, 0);
                
                document.getElementById('startBtn').disabled = true;
                document.getElementById('stopBtn').disabled = false;
            }
            
            stopVampireProcess() {
                this.isRunning = false;
                document.getElementById('startBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
                // Mute audio when stopping
                this.muteAllVoices();
            }
            
            clearVisualization() {
                this.processes.clear();
                this.events = [];
                this.activeProcesses.clear();
                this.frameCount = 0;
                this.maxDepth = 0;
                this.processCounter = 0;
                this.cursorTrails = [];
                this.drawingPath = [];
                this.updateStats();
            }
            
            clearDrawing() {
                this.drawingPath = [];
            }
            
            // Bresenham's Circle Algorithm Implementation
            bresenhamCircle(centerX, centerY, radius) {
                const points = [];
                let x = 0;
                let y = radius;
                let d = 3 - 2 * radius;
                
                // Draw the initial points
                this.addCirclePoints(points, centerX, centerY, x, y);
                
                while (y >= x) {
                    x++;
                    
                    if (d > 0) {
                        y--;
                        d = d + 4 * (x - y) + 10;
                    } else {
                        d = d + 4 * x + 6;
                    }
                    
                    this.addCirclePoints(points, centerX, centerY, x, y);
                }
                
                return points;
            }
            
            addCirclePoints(points, centerX, centerY, x, y) {
                // Add all 8 symmetric points
                points.push({x: centerX + x, y: centerY + y});
                points.push({x: centerX - x, y: centerY + y});
                points.push({x: centerX + x, y: centerY - y});
                points.push({x: centerX - x, y: centerY - y});
                points.push({x: centerX + y, y: centerY + x});
                points.push({x: centerX - y, y: centerY + x});
                points.push({x: centerX + y, y: centerY - x});
                points.push({x: centerX - y, y: centerY - x});
            }
            
            drawBresenhamCirclesAlongPath() {
                if (this.drawingPath.length < 2) return;
                
                this.ctx.strokeStyle = 'rgba(255, 68, 68, 0.6)';
                this.ctx.lineWidth = 1;
                
                // Calculate points along the path where circles should be drawn
                const circlePositions = this.calculateCirclePositions();
                
                for (const pos of circlePositions) {
                    this.drawBresenhamCircleAt(pos.x, pos.y, this.circleRadius);
                }
            }
            
            calculateCirclePositions() {
                const positions = [];
                
                for (let i = 0; i < this.drawingPath.length - 1; i++) {
                    const start = this.drawingPath[i];
                    const end = this.drawingPath[i + 1];
                    
                    const distance = Math.sqrt(
                        Math.pow(end.x - start.x, 2) + 
                        Math.pow(end.y - start.y, 2)
                    );
                    
                    const numCircles = Math.floor(distance / this.circleSpacing);
                    
                    for (let j = 0; j <= numCircles; j++) {
                        const t = j / Math.max(numCircles, 1);
                        const x = start.x + (end.x - start.x) * t;
                        const y = start.y + (end.y - start.y) * t;
                        
                        positions.push({x, y});
                    }
                }
                
                return positions;
            }
            
            drawBresenhamCircleAt(centerX, centerY, radius) {
                const points = this.bresenhamCircle(centerX, centerY, radius);
                
                this.ctx.beginPath();
                for (let i = 0; i < points.length; i++) {
                    const point = points[i];
                    if (i === 0) {
                        this.ctx.moveTo(point.x, point.y);
                    } else {
                        this.ctx.lineTo(point.x, point.y);
                    }
                }
                this.ctx.stroke();
                
                // Fill the circle with a subtle color
                this.ctx.fillStyle = 'rgba(255, 68, 68, 0.1)';
                this.ctx.beginPath();
                this.ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                this.ctx.fill();
            }
            
            drawBresenhamCirclesAlongAttractor(parent, child, time, steps, scale) {
                const phi = 1.618033988749895;
                const sigma = 10 * phi;
                const rho = 28 / phi;
                const beta = 8/3 * phi;
                
                let x = 1, y = 1, z = 1;
                const attractorPoints = [];
                
                // Generate attractor points
                for (let i = 0; i < steps; i++) {
                    const dx = sigma * (y - x);
                    const dy = x * (rho - z) - y;
                    const dz = x * y - beta * z;
                    
                    x += dx * 0.01;
                    y += dy * 0.01;
                    z += dz * 0.01;
                    
                    const progress = i / steps;
                    const baseX = parent.x + (child.x - parent.x) * progress;
                    const baseY = parent.y + (child.y - parent.y) * progress;
                    
                    const screenX = baseX + x * scale * Math.sin(time * phi);
                    const screenY = baseY + y * scale * Math.cos(time * phi);
                    
                    attractorPoints.push({x: screenX, y: screenY});
                }
                
                // Draw Bresenham circles at regular intervals along the attractor
                const circleSpacing = Math.max(1, Math.floor(attractorPoints.length / 20));
                for (let i = 0; i < attractorPoints.length; i += circleSpacing) {
                    const point = attractorPoints[i];
                    this.drawBresenhamCircleAt(point.x, point.y, this.circleRadius * 0.6);
                }
            }
            
            spawnVampireProcess(parentId, depth) {
                if (!this.isRunning) return;
                
                // Choose spawning method based on mode
                if (this.hybridPiCollatzMode) {
                    this.spawnHybridPiCollatzVampireProcess(parentId, depth);
                } else if (this.piVampireMode) {
                    this.spawnPiVampireProcess(parentId, depth);
                } else if (this.collatzVampireMode) {
                    this.spawnCollatzVampireProcess(parentId, depth);
                } else {
                    this.spawnTraditionalVampireProcess(parentId, depth);
                }
            }
            
            // Hybrid Ï€-Collatz Vampire Process Spawning
            spawnHybridPiCollatzVampireProcess(parentId, depth) {
                if (!this.isRunning) return;
                
                const processId = ++this.processCounter;
                
                // Use Collatz sequence to determine Ï€ calculation method and parameters
                const collatzStart = processId;
                const collatzResult = this.chaosMath.calculateCollatzSequence(collatzStart, 20);
                const collatzSequence = collatzResult.sequence;
                
                // Assign Ï€ calculation method based on Collatz sequence
                const piMethods = ['monteCarlo', 'buffonNeedle', 'infiniteSeries', 'goldenRatio', 'mandelbrot', 'ramanujan', 'chudnovsky', 'machin', 'gaussLegendre'];
                const methodIndex = collatzSequence[0] % piMethods.length;
                const piMethod = piMethods[methodIndex];
                
                // Use Collatz values to determine Ï€ calculation parameters
                const collatzMaxValue = collatzResult.maxValue;
                const collatzSteps = collatzResult.steps;
                const iterations = Math.min(1000 + (collatzSteps * 50), 5000);
                
                // Calculate Ï€ using assigned method with Collatz-driven parameters
                let piValue = 0;
                switch(piMethod) {
                    case 'monteCarlo':
                        piValue = this.chaosMath.calculatePiMonteCarlo(iterations);
                        break;
                    case 'buffonNeedle':
                        piValue = this.chaosMath.calculatePiBuffonNeedle(1, 2, iterations);
                        break;
                    case 'infiniteSeries':
                        piValue = this.chaosMath.calculatePiInfiniteSeries(Math.min(iterations, 1000));
                        break;
                    case 'goldenRatio':
                        piValue = this.chaosMath.calculatePiGoldenRatio(iterations);
                        break;
                    case 'mandelbrot':
                        piValue = this.chaosMath.calculatePiMandelbrot(iterations);
                        break;
                    case 'ramanujan':
                        piValue = this.chaosMath.calculatePiRamanujan(Math.min(iterations / 100, 10));
                        break;
                    case 'chudnovsky':
                        piValue = this.chaosMath.calculatePiChudnovsky(Math.min(iterations / 100, 10));
                        break;
                    case 'machin':
                        piValue = this.chaosMath.calculatePiMachin(Math.min(iterations / 50, 20));
                        break;
                    case 'gaussLegendre':
                        piValue = this.chaosMath.calculatePiGaussLegendre(Math.min(iterations / 100, 10));
                        break;
                }
                
                // Use Collatz sequence to determine spawn position
                let x, y;
                if (parentId === 0) {
                    // First process spawns in center
                    x = this.canvasWidth / 2;
                    y = this.canvasHeight / 2;
                } else {
                    // Child processes spawn based on Collatz sequence and Ï€ accuracy
                    const parentProcess = this.processes.get(parentId);
                    const accuracy = this.calculatePiAccuracy(piValue);
                    const collatzValue = collatzSequence[Math.min(depth, collatzSequence.length - 1)];
                    
                    // Combine Collatz and Ï€ factors for positioning
                    const collatzAngle = (collatzValue * 0.1) % (Math.PI * 2);
                    const piAngle = (methodIndex * Math.PI * 2 / piMethods.length);
                    const combinedAngle = (collatzAngle + piAngle) / 2;
                    
                    const collatzDistance = (collatzValue % 80) + 40;
                    const piDistance = 60 + (accuracy * 0.5);
                    const combinedDistance = (collatzDistance + piDistance) / 2;
                    
                    x = parentProcess.x + Math.cos(combinedAngle) * combinedDistance;
                    y = parentProcess.y + Math.sin(combinedAngle) * combinedDistance;
                    
                    // Keep within canvas bounds
                    x = Math.max(30, Math.min(this.canvasWidth - 30, x));
                    y = Math.max(30, Math.min(this.canvasHeight - 30, y));
                }
                
                const process = {
                    id: processId,
                    parentId: parentId,
                    x: x,
                    y: y,
                    originalX: x,
                    originalY: y,
                    depth: depth,
                    state: 'spawning',
                    spawnTime: Date.now(),
                    lifeTime: 0,
                    // Ï€ properties
                    piMethod: piMethod,
                    piValue: piValue,
                    piAccuracy: this.calculatePiAccuracy(piValue),
                    piIterations: iterations,
                    // Collatz properties
                    collatzSequence: collatzSequence,
                    collatzSteps: collatzSteps,
                    collatzMaxValue: collatzMaxValue,
                    // Hybrid properties
                    hybridMode: true,
                    collatzPiMethod: methodIndex
                };
                
                this.processes.set(processId, process);
                this.activeProcesses.add(processId);
                this.maxDepth = Math.max(this.maxDepth, depth);
                
                // Record the spawn event
                this.events.push({
                    type: 'spawn',
                    processId: processId,
                    parentId: parentId,
                    timestamp: Date.now(),
                    depth: depth,
                    piMethod: piMethod,
                    piValue: piValue,
                    piAccuracy: this.calculatePiAccuracy(piValue),
                    collatzSteps: collatzSteps,
                    hybridMode: true
                });
                
                // Use both Collatz and Ï€ accuracy to determine timing
                const collatzDelay = Math.max(20, 150 - collatzSteps);
                const piDelay = Math.max(20, 150 - this.calculatePiAccuracy(piValue));
                const hybridDelay = Math.min(collatzDelay, piDelay);
                
                const collatzLifetime = Math.max(100, 300 - collatzSteps);
                const piLifetime = Math.max(100, 300 - this.calculatePiAccuracy(piValue));
                const hybridLifetime = Math.max(collatzLifetime, piLifetime);
                
                // Immediately spawn a child (vampire behavior with hybrid timing)
                setTimeout(() => {
                    if (this.isRunning) {
                        this.spawnHybridPiCollatzVampireProcess(processId, depth + 1);
                    }
                }, hybridDelay);
                
                // Process dies after spawning (vampire behavior with hybrid lifetime)
                setTimeout(() => {
                    this.killProcess(processId);
                }, hybridLifetime);
            }
            
            // Ï€-Solving Vampire Process Spawning
            spawnPiVampireProcess(parentId, depth) {
                if (!this.isRunning) return;
                
                const processId = ++this.processCounter;
                
                // Assign Ï€ calculation method to this process
                const piMethods = ['monteCarlo', 'buffonNeedle', 'infiniteSeries', 'goldenRatio', 'mandelbrot', 'ramanujan', 'chudnovsky', 'machin', 'gaussLegendre'];
                const piMethod = piMethods[processId % piMethods.length];
                
                // Calculate Ï€ using assigned method
                let piValue = 0;
                const iterations = Math.min(1000 + depth * 100, 5000);
                
                switch(piMethod) {
                    case 'monteCarlo':
                        piValue = this.chaosMath.calculatePiMonteCarlo(iterations);
                        break;
                    case 'buffonNeedle':
                        piValue = this.chaosMath.calculatePiBuffonNeedle(1, 2, iterations);
                        break;
                    case 'infiniteSeries':
                        piValue = this.chaosMath.calculatePiInfiniteSeries(Math.min(iterations, 1000));
                        break;
                    case 'goldenRatio':
                        piValue = this.chaosMath.calculatePiGoldenRatio(iterations);
                        break;
                    case 'mandelbrot':
                        piValue = this.chaosMath.calculatePiMandelbrot(iterations);
                        break;
                    case 'ramanujan':
                        piValue = this.chaosMath.calculatePiRamanujan(Math.min(iterations / 100, 10));
                        break;
                    case 'chudnovsky':
                        piValue = this.chaosMath.calculatePiChudnovsky(Math.min(iterations / 100, 10));
                        break;
                    case 'machin':
                        piValue = this.chaosMath.calculatePiMachin(Math.min(iterations / 50, 20));
                        break;
                    case 'gaussLegendre':
                        piValue = this.chaosMath.calculatePiGaussLegendre(Math.min(iterations / 100, 10));
                        break;
                }
                
                // Use Ï€ value and method to determine spawn position
                let x, y;
                if (parentId === 0) {
                    // First process spawns in center
                    x = this.canvasWidth / 2;
                    y = this.canvasHeight / 2;
                } else {
                    // Child processes spawn based on Ï€ method and accuracy
                    const parentProcess = this.processes.get(parentId);
                    const accuracy = this.calculatePiAccuracy(piValue);
                    const methodIndex = piMethods.indexOf(piMethod);
                    
                    // Spawn in method-specific regions
                    const angle = (methodIndex * Math.PI * 2 / piMethods.length) + (accuracy * 0.1);
                    const distance = 60 + (accuracy * 0.5);
                    
                    x = parentProcess.x + Math.cos(angle) * distance;
                    y = parentProcess.y + Math.sin(angle) * distance;
                    
                    // Keep within canvas bounds
                    x = Math.max(30, Math.min(this.canvasWidth - 30, x));
                    y = Math.max(30, Math.min(this.canvasHeight - 30, y));
                }
                
                const process = {
                    id: processId,
                    parentId: parentId,
                    x: x,
                    y: y,
                    originalX: x,
                    originalY: y,
                    depth: depth,
                    state: 'spawning',
                    spawnTime: Date.now(),
                    lifeTime: 0,
                    piMethod: piMethod,
                    piValue: piValue,
                    piAccuracy: this.calculatePiAccuracy(piValue),
                    piIterations: iterations
                };
                
                this.processes.set(processId, process);
                this.activeProcesses.add(processId);
                this.maxDepth = Math.max(this.maxDepth, depth);
                
                // Record the spawn event
                this.events.push({
                    type: 'spawn',
                    processId: processId,
                    parentId: parentId,
                    timestamp: Date.now(),
                    depth: depth,
                    piMethod: piMethod,
                    piValue: piValue,
                    piAccuracy: this.calculatePiAccuracy(piValue)
                });
                
                // Use Ï€ accuracy to determine spawn timing (more accurate = faster spawning)
                const accuracyDelay = Math.max(20, 150 - this.calculatePiAccuracy(piValue));
                const accuracyLifetime = Math.max(100, 300 - this.calculatePiAccuracy(piValue));
                
                // Immediately spawn a child (vampire behavior with Ï€-based timing)
                setTimeout(() => {
                    if (this.isRunning) {
                        this.spawnPiVampireProcess(processId, depth + 1);
                    }
                }, accuracyDelay);
                
                // Process dies after spawning (vampire behavior with Ï€-based lifetime)
                setTimeout(() => {
                    this.killProcess(processId);
                }, accuracyLifetime);
            }
            
            calculatePiAccuracy(piValue) {
                if (piValue === 0) return 0;
                const actualPi = Math.PI;
                const error = Math.abs(piValue - actualPi);
                const accuracy = Math.max(0, 100 - (error / actualPi) * 100);
                return Math.min(100, accuracy);
            }
            
            // Traditional Vampire Process Spawning
            spawnTraditionalVampireProcess(parentId, depth) {
                if (!this.isRunning) return;
                
                const processId = ++this.processCounter;
                const x = Math.random() * (this.canvasWidth - 100) + 50;
                const y = Math.random() * (this.canvasHeight - 100) + 50;
                
                const process = {
                    id: processId,
                    parentId: parentId,
                    x: x,
                    y: y,
                    originalX: x,
                    originalY: y,
                    depth: depth,
                    state: 'spawning',
                    spawnTime: Date.now(),
                    lifeTime: 0
                };
                
                this.processes.set(processId, process);
                this.activeProcesses.add(processId);
                this.maxDepth = Math.max(this.maxDepth, depth);
                
                // Record the spawn event
                this.events.push({
                    type: 'spawn',
                    processId: processId,
                    parentId: parentId,
                    timestamp: Date.now(),
                    depth: depth
                });
                
                // Immediately spawn a child (vampire behavior)
                setTimeout(() => {
                    if (this.isRunning) {
                        this.spawnVampireProcess(processId, depth + 1);
                    }
                }, Math.random() * 100 + 50); // Random delay 50-150ms
                
                // Process dies after spawning (vampire behavior)
                setTimeout(() => {
                    this.killProcess(processId);
                }, Math.random() * 200 + 100); // Random lifetime 100-300ms
            }
            
            // Collatz-driven Vampire Process Spawning
            spawnCollatzVampireProcess(parentId, depth) {
                if (!this.isRunning) return;
                
                const processId = ++this.processCounter;
                
                // Use Collatz sequence to determine spawn position
                const collatzStart = processId;
                const collatzResult = this.chaosMath.calculateCollatzSequence(collatzStart, 20);
                const collatzSequence = collatzResult.sequence;
                
                // Use Collatz values to determine spawn coordinates
                let x, y;
                if (parentId === 0) {
                    // First process spawns in center
                    x = this.canvasWidth / 2;
                    y = this.canvasHeight / 2;
                } else {
                    // Child processes spawn based on Collatz sequence
                    const parentProcess = this.processes.get(parentId);
                    const collatzValue = collatzSequence[Math.min(depth, collatzSequence.length - 1)];
                    const angle = (collatzValue * 0.1) % (Math.PI * 2);
                    const distance = (collatzValue % 80) + 40;
                    
                    x = parentProcess.x + Math.cos(angle) * distance;
                    y = parentProcess.y + Math.sin(angle) * distance;
                    
                    // Keep within canvas bounds
                    x = Math.max(30, Math.min(this.canvasWidth - 30, x));
                    y = Math.max(30, Math.min(this.canvasHeight - 30, y));
                }
                
                const process = {
                    id: processId,
                    parentId: parentId,
                    x: x,
                    y: y,
                    originalX: x,
                    originalY: y,
                    depth: depth,
                    state: 'spawning',
                    spawnTime: Date.now(),
                    lifeTime: 0,
                    collatzSequence: collatzSequence,
                    collatzSteps: collatzResult.steps,
                    collatzMaxValue: collatzResult.maxValue
                };
                
                this.processes.set(processId, process);
                this.activeProcesses.add(processId);
                this.maxDepth = Math.max(this.maxDepth, depth);
                
                // Record the spawn event
                this.events.push({
                    type: 'spawn',
                    processId: processId,
                    parentId: parentId,
                    timestamp: Date.now(),
                    depth: depth,
                    collatzSteps: collatzResult.steps
                });
                
                // Use Collatz sequence to determine spawn timing
                const collatzDelay = (collatzResult.steps % 100) + 50;
                const collatzLifetime = (collatzResult.maxValue % 200) + 100;
                
                // Immediately spawn a child (vampire behavior with Collatz timing)
                setTimeout(() => {
                    if (this.isRunning) {
                        this.spawnCollatzVampireProcess(processId, depth + 1);
                    }
                }, collatzDelay);
                
                // Process dies after spawning (vampire behavior with Collatz lifetime)
                setTimeout(() => {
                    this.killProcess(processId);
                }, collatzLifetime);
            }
            
            killProcess(processId) {
                const process = this.processes.get(processId);
                if (process) {
                    process.state = 'dying';
                    this.activeProcesses.delete(processId);
                    
                    // Record the death event
                    this.events.push({
                        type: 'death',
                        processId: processId,
                        timestamp: Date.now(),
                        depth: process.depth
                    });
                    
                    // Remove process after death animation
                    setTimeout(() => {
                        this.processes.delete(processId);
                    }, 500);
                }
            }
            
            update() {
                this.frameCount++;
                
                // Update process states and add chaotic movement
                for (const [id, process] of this.processes) {
                    process.lifeTime = Date.now() - process.spawnTime;
                    
                    if (process.state === 'spawning' && process.lifeTime > 50) {
                        process.state = 'active';
                    }
                    
                    // Add chaotic butterfly movement
                    this.updateChaoticMovement(process);
                }
                
                // Update cursor following
                this.updateCursorTarget();
                this.updateCursorMovement();
                
                this.updateStats();
            }
            
            updateChaoticMovement(process) {
                if (!this.chaosMath.isComponentEnabled('chaoticMovement')) return;
                
                const time = Date.now() * 0.001;
                const movement = this.chaosMath.calculateChaoticMovement(process, time);
                
                // Add some drift to the original position
                process.originalX = process.originalX || process.x;
                process.originalY = process.originalY || process.y;
                
                // Update position with chaotic movement
                process.x = process.originalX + movement.chaosX;
                process.y = process.originalY + movement.chaosY;
                
                // Keep butterflies within canvas bounds
                process.x = Math.max(30, Math.min(this.canvasWidth - 30, process.x));
                process.y = Math.max(30, Math.min(this.canvasHeight - 30, process.y));
            }
            
            draw() {
                // Clear canvas
                this.ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);
                
                // Draw Mandelbrot field background
                this.drawMandelbrotField();
                
                // Draw grid
                this.drawGrid();
                
                // Draw cursor trail
                this.drawCursorTrail();
                
                // Draw process connections
                this.drawConnections();
                
                // Draw processes
                this.drawProcesses();
                
                // Draw black lines
                this.drawBlackLines();
                
                // Draw infinite Ï€ visualization if active
                this.drawInfinitePiVisualization();
                
                // Draw Collatz visualization if active
                this.drawCollatzVisualization();
                
                // Draw info
                this.drawInfo();
            }
            
            drawBlackLines() {
                if (this.drawingPath.length < 2) return;
                
                this.ctx.strokeStyle = 'black';
                this.ctx.lineWidth = 3;
                this.ctx.lineCap = 'round';
                this.ctx.beginPath();
                
                this.ctx.moveTo(this.drawingPath[0].x, this.drawingPath[0].y);
                for (let i = 1; i < this.drawingPath.length; i++) {
                    this.ctx.lineTo(this.drawingPath[i].x, this.drawingPath[i].y);
                }
                this.ctx.stroke();
                
                // Draw Bresenham circles along the line if enabled
                if (this.bresenhamCirclesEnabled) {
                    this.drawBresenhamCirclesAlongPath();
                }
            }
            
            drawGrid() {
                this.ctx.strokeStyle = '#e0e0e0';
                this.ctx.lineWidth = 1;
                
                // Vertical lines
                for (let x = 0; x <= this.canvasWidth; x += 50) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.canvasHeight);
                    this.ctx.stroke();
                }
                
                // Horizontal lines
                for (let y = 0; y <= this.canvasHeight; y += 50) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvasWidth, y);
                    this.ctx.stroke();
                }
            }
            
            drawCursorTrail() {
                // Draw cursor trail with butterfly shapes
                for (let i = 0; i < this.cursorTrails.length; i++) {
                    const trail = this.cursorTrails[i];
                    const alpha = trail.life;
                    const size = 8 * alpha;
                    
                    this.drawButterflyShape(trail.x, trail.y, size, alpha * 0.6);
                }
                
                // Draw cursor position indicator with butterfly
                this.drawButterflyShape(this.cursorPosition.x, this.cursorPosition.y, 20, 0.3);
                
                // Draw outer glow
                this.ctx.fillStyle = 'rgba(255, 68, 68, 0.2)';
                this.ctx.beginPath();
                this.ctx.arc(this.cursorPosition.x, this.cursorPosition.y, 35, 0, 2 * Math.PI);
                this.ctx.fill();
            }
            
            drawButterflyShape(x, y, size, alpha) {
                const wingSize = size * 0.8;
                const bodySize = size * 0.3;
                const flap = Math.sin(Date.now() * 0.01) * 0.1;
                
                this.ctx.save();
                this.ctx.globalAlpha = alpha;
                this.ctx.translate(x, y);
                
                // Draw left wing
                this.ctx.fillStyle = `rgba(255, 68, 68, ${alpha})`;
                this.ctx.beginPath();
                this.ctx.ellipse(-wingSize/3, -wingSize/4 + flap, wingSize/2, wingSize/3, -0.3, 0, 2 * Math.PI);
                this.ctx.fill();
                
                // Draw right wing
                this.ctx.beginPath();
                this.ctx.ellipse(wingSize/3, -wingSize/4 - flap, wingSize/2, wingSize/3, 0.3, 0, 2 * Math.PI);
                this.ctx.fill();
                
                // Draw body
                this.ctx.fillStyle = `rgba(51, 51, 51, ${alpha})`;
                this.ctx.beginPath();
                this.ctx.ellipse(0, 0, bodySize/4, bodySize, 0, 0, 2 * Math.PI);
                this.ctx.fill();
                
                // Add wing details
                this.ctx.fillStyle = `rgba(255, 102, 102, ${alpha * 0.7})`;
                this.ctx.beginPath();
                this.ctx.ellipse(-wingSize/3, -wingSize/4 + flap, wingSize/4, wingSize/6, -0.3, 0, 2 * Math.PI);
                this.ctx.fill();
                
                this.ctx.beginPath();
                this.ctx.ellipse(wingSize/3, -wingSize/4 - flap, wingSize/4, wingSize/6, 0.3, 0, 2 * Math.PI);
                this.ctx.fill();
                
                this.ctx.restore();
            }
            
            drawConnections() {
                // Draw Collatz-driven connections between vampire processes
                this.drawCollatzConnections();
                
                // Also draw traditional Lorenz attractors if enabled
                if (this.chaosMath.isComponentEnabled('lorenzAttractor')) {
                    this.drawLorenzConnections();
                }
            }
            
            drawLorenzConnections() {
                // Original Lorenz attractor connections
                const processArray = Array.from(this.processes.values());
                
                for (let i = 0; i < processArray.length; i++) {
                    for (let j = i + 1; j < processArray.length; j++) {
                        const process1 = processArray[i];
                        const process2 = processArray[j];
                        const distance = Math.sqrt(
                            Math.pow(process2.x - process1.x, 2) + 
                            Math.pow(process2.y - process1.y, 2)
                        );
                        
                        // Only draw connections for nearby processes
                        if (distance < 250) {
                            this.drawLorenzAttractor(process1, process2);
                        }
                    }
                }
            }
            
            // Collatz-driven Vampire Process Connections
            drawCollatzConnections() {
                const processArray = Array.from(this.processes.values());
                
                for (let i = 0; i < processArray.length; i++) {
                    for (let j = i + 1; j < processArray.length; j++) {
                        const process1 = processArray[i];
                        const process2 = processArray[j];
                        const distance = Math.sqrt(
                            Math.pow(process2.x - process1.x, 2) + 
                            Math.pow(process2.y - process1.y, 2)
                        );
                        
                        // Only draw connections for nearby processes
                        if (distance < 300) {
                            this.drawCollatzPath(process1, process2);
                        }
                    }
                }
            }
            
            drawCollatzPath(process1, process2) {
                // Use process IDs to generate Collatz sequence for path
                const collatzStart = Math.abs(process1.id - process2.id) + 1;
                const collatzSequence = this.chaosMath.calculateCollatzSequence(collatzStart, 50);
                
                // Create path points based on Collatz sequence
                const pathPoints = this.generateCollatzPathPoints(process1, process2, collatzSequence.sequence);
                
                // Draw the Collatz-driven path
                this.drawCollatzPathCurve(pathPoints, collatzSequence);
            }
            
            generateCollatzPathPoints(process1, process2, collatzSequence) {
                const points = [];
                const totalSteps = collatzSequence.length;
                const maxValue = Math.max(...collatzSequence);
                
                for (let i = 0; i < totalSteps; i++) {
                    const t = i / (totalSteps - 1);
                    const collatzValue = collatzSequence[i];
                    
                    // Linear interpolation between processes
                    const baseX = process1.x + (process2.x - process1.x) * t;
                    const baseY = process1.y + (process2.y - process1.y) * t;
                    
                    // Use Collatz value to create deviations
                    const deviation = (collatzValue / maxValue) * 50;
                    const angle = (i / totalSteps) * Math.PI * 4; // Multiple spirals
                    
                    // Add Collatz-based chaos
                    const chaosX = Math.sin(angle) * deviation * Math.sin(collatzValue * 0.1);
                    const chaosY = Math.cos(angle) * deviation * Math.cos(collatzValue * 0.1);
                    
                    points.push({
                        x: baseX + chaosX,
                        y: baseY + chaosY,
                        collatzValue: collatzValue,
                        step: i,
                        isEven: collatzValue % 2 === 0
                    });
                }
                
                return points;
            }
            
            drawCollatzPathCurve(pathPoints, collatzSequence) {
                if (pathPoints.length < 2) return;
                
                // Draw main path
                this.ctx.strokeStyle = `rgba(255, 68, 68, 0.7)`;
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                
                let firstPoint = true;
                for (const point of pathPoints) {
                    if (firstPoint) {
                        this.ctx.moveTo(point.x, point.y);
                        firstPoint = false;
                    } else {
                        this.ctx.lineTo(point.x, point.y);
                    }
                }
                this.ctx.stroke();

                // Draw animated sine waves along the path segments
                if (this.sineWavesEnabled) {
                    this.drawSineWavesOnPath(pathPoints);
                }
                
                // Draw Collatz value indicators
                for (let i = 0; i < pathPoints.length; i += 3) {
                    const point = pathPoints[i];
                    const alpha = 0.3 + (point.collatzValue / Math.max(...collatzSequence.sequence)) * 0.4;
                    
                    // Different colors for even/odd Collatz values
                    const color = point.isEven ? 
                        `rgba(68, 255, 68, ${alpha})` : 
                        `rgba(255, 255, 68, ${alpha})`;
                    
                    this.ctx.fillStyle = color;
                    this.ctx.beginPath();
                    this.ctx.arc(point.x, point.y, 3, 0, 2 * Math.PI);
                    this.ctx.fill();
                }
                
                // Draw Collatz sequence as branching paths
                this.drawCollatzBranches(pathPoints, collatzSequence);
            }

            drawSineWavesOnPath(pathPoints) {
                const time = Date.now() * 0.001; // seconds
                // Iterate adjacent pairs (segments)
                for (let i = 0; i < pathPoints.length - 1; i++) {
                    const p0 = pathPoints[i];
                    const p1 = pathPoints[i + 1];
                    const dx = p1.x - p0.x;
                    const dy = p1.y - p0.y;
                    const len = Math.max(1, Math.hypot(dx, dy));
                    const nx = -dy / len; // unit normal x
                    const ny = dx / len;  // unit normal y
                    
                    // Per-segment temporal frequency (Hz) â€” varies by index and time
                    const baseHz = this.sineBaseHz; // user base
                    const hz = baseHz + 0.35 * Math.sin(i * 0.77 + time * 0.6) + (i % 5) * 0.1;
                    const omegaT = 2 * Math.PI * hz * time;
                    
                    // Spatial cycles along the segment
                    const spatialCycles = this.sineSpatialCyclesBase + (i % 4) * 0.4;
                    
                    // Amplitude scaled by length but capped
                    const amplitude = Math.min(18, this.sineAmplitudeBase + len * 0.04);
                    
                    // Steps based on segment length
                    const steps = Math.max(8, Math.floor(len / 5));
                    
                    // Fixed purple color for sine waves
                    this.ctx.strokeStyle = 'hsla(270, 90%, 65%, 0.6)';
                    this.ctx.lineWidth = 1.8;
                    this.ctx.beginPath();
                    for (let s = 0; s <= steps; s++) {
                        const t = s / steps; // 0..1 along segment
                        const x = p0.x + dx * t;
                        const y = p0.y + dy * t;
                        const phase = 2 * Math.PI * spatialCycles * t + omegaT;
                        const off = amplitude * Math.sin(phase);
                        const wx = x + nx * off;
                        const wy = y + ny * off;
                        if (s === 0) this.ctx.moveTo(wx, wy); else this.ctx.lineTo(wx, wy);
                    }
                    this.ctx.stroke();

                    // Drive a limited pool of audio voices by segment frequency
                    if (this.audioEnabled) {
                        this.updateAudioForSegment(i, hz);
                    }
                }
            }

            muteAllVoices() {
                if (!this.audioContext || !this.sineVoices || !this.sineVoices.length) return;
                for (const v of this.sineVoices) {
                    if (v && v.gain && v.gain.gain) {
                        try {
                            v.gain.gain.setTargetAtTime(0.0, this.audioContext.currentTime, 0.03);
                        } catch (e) {
                            v.gain.gain.value = 0.0;
                        }
                    }
                }
            }

            ensureAudio() {
                if (this.audioContext) return;
                const AudioCtx = window.AudioContext || window.webkitAudioContext;
                this.audioContext = new AudioCtx();
                this.masterGain = this.audioContext.createGain();
                this.masterGain.gain.value = this.audioVolume;
                this.masterGain.connect(this.audioContext.destination);
                // Pre-create voice pool
                this.sineVoices = [];
                for (let i = 0; i < this.maxSineVoices; i++) {
                    const osc = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();
                    osc.type = 'sine';
                    // Start silent
                    gain.gain.value = 0.0;
                    osc.frequency.value = 220;
                    osc.connect(gain);
                    gain.connect(this.masterGain);
                    osc.start();
                    this.sineVoices.push({ osc, gain, inUse: false, lastIndex: -1 });
                }
            }

            updateAudioForSegment(segIndex, hz) {
                this.ensureAudio();
                // Map segment index to a stable voice slot
                const voiceIdx = segIndex % this.maxSineVoices;
                const voice = this.sineVoices[voiceIdx];
                voice.inUse = true;
                voice.lastIndex = segIndex;
                // Map low visual Hz (0.5..~3) to musical frequency range (e.g., 110..880 Hz)
                const freq = 110 * Math.pow(2, hz * 1.2); // exponential mapping
                // Smoothly target frequency
                if (voice.osc.frequency.setTargetAtTime) {
                    voice.osc.frequency.setTargetAtTime(freq, this.audioContext.currentTime, 0.05);
                } else {
                    voice.osc.frequency.value = freq;
                }
                // Set per-voice gain softly based on segment length/hz
                const level = Math.min(0.18, 0.06 + hz * 0.04);
                if (voice.gain.gain.setTargetAtTime) {
                    voice.gain.gain.setTargetAtTime(this.audioEnabled ? level : 0.0, this.audioContext.currentTime, 0.05);
                } else {
                    voice.gain.gain.value = this.audioEnabled ? level : 0.0;
                }
            }
            
            drawCollatzBranches(pathPoints, collatzSequence) {
                for (let i = 1; i < pathPoints.length - 1; i++) {
                    const point = pathPoints[i];
                    const collatzValue = point.collatzValue;
                    
                    // Create branches based on Collatz values
                    if (collatzValue > 10 && collatzValue % 7 === 0) {
                        const branchLength = (collatzValue % 20) + 10;
                        const branchAngle = (collatzValue * 0.1) % (Math.PI * 2);
                        
                        const branchX = point.x + Math.cos(branchAngle) * branchLength;
                        const branchY = point.y + Math.sin(branchAngle) * branchLength;
                        
                        this.ctx.strokeStyle = `rgba(255, 150, 150, 0.4)`;
                        this.ctx.lineWidth = 1;
                        this.ctx.beginPath();
                        this.ctx.moveTo(point.x, point.y);
                        this.ctx.lineTo(branchX, branchY);
                        this.ctx.stroke();
                        
                        // Add sub-branches for high Collatz values
                        if (collatzValue > 50) {
                            this.drawCollatzSubBranches(point, collatzValue);
                        }
                    }
                }
            }
            
            drawCollatzSubBranches(parentPoint, collatzValue) {
                const subBranches = Math.min(Math.floor(collatzValue / 25), 3);
                
                for (let i = 0; i < subBranches; i++) {
                    const subAngle = (collatzValue * 0.05 + i * Math.PI / 3) % (Math.PI * 2);
                    const subLength = (collatzValue % 15) + 5;
                    
                    const subX = parentPoint.x + Math.cos(subAngle) * subLength;
                    const subY = parentPoint.y + Math.sin(subAngle) * subLength;
                    
                    this.ctx.strokeStyle = `rgba(255, 200, 200, 0.3)`;
                    this.ctx.lineWidth = 0.5;
                    this.ctx.beginPath();
                    this.ctx.moveTo(parentPoint.x, parentPoint.y);
                    this.ctx.lineTo(subX, subY);
                    this.ctx.stroke();
                }
            }
            
            drawLorenzAttractor(parent, child) {
                if (!this.chaosMath.isComponentEnabled('lorenzAttractor')) return;
                
                const time = Date.now() * 0.001;
                const steps = 150;
                const scale = 25;
                const phi = this.chaosMath.phi;
                
                // Draw multiple coexisting attractors using golden ratio parameters
                this.drawCoexistingAttractor(parent, child, time, steps, scale, 10 * phi, 28 / phi, 8/3 * phi, 0, `rgba(255, 102, 102, 0.6)`, 1);
                this.drawCoexistingAttractor(parent, child, time, steps, scale, 10 / phi, 28 * phi, 8/3 / phi, 1, `rgba(255, 150, 150, 0.5)`, 0.8);
                this.drawCoexistingAttractor(parent, child, time, steps, scale, 10 * phi * phi, 28 / phi / phi, 8/3 * phi * phi, 2, `rgba(255, 200, 200, 0.4)`, 0.6);
                this.drawCoexistingAttractor(parent, child, time, steps, scale, 10 / phi / phi, 28 * phi * phi, 8/3 / phi / phi, 3, `rgba(255, 100, 100, 0.3)`, 0.4);
                
                // Add Bresenham circles along the attractor if enabled
                if (this.bresenhamCirclesEnabled) {
                    this.drawBresenhamCirclesAlongAttractor(parent, child, time, steps, scale);
                }
            }
            
            drawCoexistingAttractor(parent, child, time, steps, scale, sigma, rho, beta, offset, color, lineWidth) {
                const attractorPoints = this.chaosMath.calculateLorenzAttractor(parent, child, time, steps, scale, sigma, rho, beta, offset);
                
                // Draw first half (upper wing)
                this.ctx.strokeStyle = color;
                this.ctx.lineWidth = lineWidth;
                this.ctx.beginPath();
                
                let firstPoint = true;
                for (const point of attractorPoints) {
                    if (point.wing === 'upper') {
                        if (firstPoint) {
                            this.ctx.moveTo(point.x, point.y);
                            firstPoint = false;
                        } else {
                            this.ctx.lineTo(point.x, point.y);
                        }
                    }
                }
                this.ctx.stroke();
                
                // Draw second half (lower wing) - flipped direction
                this.ctx.strokeStyle = color.replace('0.6', '0.8').replace('0.5', '0.7').replace('0.4', '0.6').replace('0.3', '0.5');
                this.ctx.lineWidth = lineWidth * 0.8;
                this.ctx.beginPath();
                
                firstPoint = true;
                for (const point of attractorPoints) {
                    if (point.wing === 'lower') {
                        if (firstPoint) {
                            this.ctx.moveTo(point.x, point.y);
                            firstPoint = false;
                        } else {
                            this.ctx.lineTo(point.x, point.y);
                        }
                    }
                }
                this.ctx.stroke();
                
                // Add secondary coexisting attractor with golden ratio parameters
                this.drawSecondaryAttractor(parent, child, time, steps, scale, offset, color);
            }
            
            drawSecondaryAttractor(parent, child, time, steps, scale, offset, baseColor) {
                const secondaryPoints = this.chaosMath.calculateSecondaryAttractor(parent, child, time, steps, scale, offset);
                
                this.ctx.strokeStyle = baseColor.replace('0.6', '0.3').replace('0.5', '0.2').replace('0.4', '0.15').replace('0.3', '0.1');
                this.ctx.lineWidth = 0.5;
                this.ctx.beginPath();
                
                let firstPoint = true;
                for (const point of secondaryPoints) {
                    if (firstPoint) {
                        this.ctx.moveTo(point.x, point.y);
                        firstPoint = false;
                    } else {
                        this.ctx.lineTo(point.x, point.y);
                    }
                }
                this.ctx.stroke();
            }
            
            drawChaoticConnection(process1, process2, seed) {
                const time = Date.now() * 0.002;
                const steps = 100;
                
                // Use seed for variation
                const chaos1 = Math.sin(seed * 0.1 + time) * 0.5;
                const chaos2 = Math.cos(seed * 0.15 + time * 1.3) * 0.3;
                
                this.ctx.strokeStyle = `rgba(255, 150, 150, 0.4)`;
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                
                let firstPoint = true;
                for (let i = 0; i <= steps; i++) {
                    const t = i / steps;
                    
                    // Chaotic interpolation
                    const baseX = process1.x + (process2.x - process1.x) * t;
                    const baseY = process1.y + (process2.y - process1.y) * t;
                    
                    // Add chaos
                    const chaosX = Math.sin(t * Math.PI * 4 + time + seed) * 20 * (1 - Math.abs(t - 0.5) * 2);
                    const chaosY = Math.cos(t * Math.PI * 6 + time * 1.5 + seed) * 15 * (1 - Math.abs(t - 0.5) * 2);
                    
                    const x = baseX + chaosX + chaos1 * 10;
                    const y = baseY + chaosY + chaos2 * 8;
                    
                    if (firstPoint) {
                        this.ctx.moveTo(x, y);
                        firstPoint = false;
                    } else {
                        this.ctx.lineTo(x, y);
                    }
                }
                this.ctx.stroke();
                
                // Add fractal-like branching
                this.drawFractalBranches(process1, process2, seed, time);
            }
            
            drawFractalBranches(process1, process2, seed, time) {
                if (!this.chaosMath.isComponentEnabled('fractalBranches')) return;
                
                const branches = this.chaosMath.calculateFractalBranches(process1, process2, seed, time);
                
                for (const branch of branches) {
                    this.ctx.strokeStyle = `rgba(255, 200, 200, 0.3)`;
                    this.ctx.lineWidth = 0.5;
                    this.ctx.beginPath();
                    this.ctx.moveTo(branch.startX, branch.startY);
                    this.ctx.lineTo(branch.endX, branch.endY);
                    this.ctx.stroke();
                    
                    // Draw sub-branches
                    for (const subBranch of branch.subBranches) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(subBranch.startX, subBranch.startY);
                        this.ctx.lineTo(subBranch.endX, subBranch.endY);
                        this.ctx.stroke();
                    }
                }
            }
            
            drawMandelbrotField() {
                if (!this.chaosMath.isComponentEnabled('mandelbrotField')) return;
                
                // Draw a subtle Mandelbrot-inspired background field
                const time = Date.now() * 0.0005;
                const mandelbrotPoints = this.chaosMath.calculateMandelbrotField(this.canvasWidth, this.canvasHeight, time);
                
                for (const point of mandelbrotPoints) {
                    this.ctx.fillStyle = `rgba(255, 100, 100, ${point.intensity * 0.1})`;
                    this.ctx.fillRect(point.x, point.y, 2, 2);
                }
            }
            
            drawProcesses() {
                // Choose drawing method based on vampire mode
                if (this.hybridPiCollatzMode) {
                    this.drawHybridProcesses();
                } else if (this.piVampireMode) {
                    this.drawPiProcesses();
                } else {
                    this.drawTraditionalProcesses();
                }
            }
            
            // Hybrid Ï€-Collatz Process Drawing
            drawHybridProcesses() {
                for (const [id, process] of this.processes) {
                    const alpha = process.state === 'dying' ? 0.3 : 1.0;
                    const size = this.processRadius * 2;
                    
                    // Color based on both Ï€ method and Collatz properties
                    const methodColors = {
                        'monteCarlo': [255, 100, 100],
                        'buffonNeedle': [100, 255, 100],
                        'infiniteSeries': [100, 100, 255],
                        'goldenRatio': [255, 255, 100],
                        'mandelbrot': [255, 100, 255],
                        'ramanujan': [100, 255, 255],
                        'chudnovsky': [255, 150, 100],
                        'machin': [150, 255, 150],
                        'gaussLegendre': [150, 150, 255]
                    };
                    
                    const baseColor = methodColors[process.piMethod] || [255, 100, 100];
                    const accuracy = process.piAccuracy || 0;
                    const collatzIntensity = Math.min(process.collatzSteps / 100, 1);
                    
                    // Adjust color intensity based on both Ï€ accuracy and Collatz properties
                    const piIntensity = 0.5 + (accuracy / 100) * 0.5;
                    const hybridIntensity = (piIntensity + collatzIntensity) / 2;
                    const color = `rgba(${baseColor[0] * hybridIntensity}, ${baseColor[1] * hybridIntensity}, ${baseColor[2] * hybridIntensity}, ${alpha})`;
                    
                    // Draw hybrid butterfly process
                    this.drawHybridButterflyProcess(process.x, process.y, size, alpha, process.state, color, process);
                    
                    // Draw Ï€ value and accuracy
                    this.ctx.fillStyle = 'white';
                    this.ctx.font = 'bold 8px Arial';
                    this.ctx.globalAlpha = alpha;
                    this.ctx.textAlign = 'center';
                    
                    // Show Ï€ value (truncated)
                    const piDisplay = process.piValue ? process.piValue.toFixed(4) : '0.0000';
                    this.ctx.fillText(piDisplay, process.x, process.y - 20);
                    
                    // Show accuracy percentage
                    const accuracyDisplay = `${Math.round(process.piAccuracy || 0)}%`;
                    this.ctx.fillText(accuracyDisplay, process.x, process.y + 5);
                    
                    // Show Collatz steps
                    const collatzDisplay = `C:${process.collatzSteps}`;
                    this.ctx.fillText(collatzDisplay, process.x, process.y + 18);
                    
                    // Draw method indicator
                    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    this.ctx.font = '6px Arial';
                    this.ctx.fillText(process.piMethod?.substring(0, 4) || 'N/A', process.x, process.y + 30);
                    
                    this.ctx.globalAlpha = 1.0;
                }
            }
            
            drawHybridButterflyProcess(x, y, size, alpha, state, color, process) {
                const wingSize = size * 0.8;
                const bodySize = size * 0.4;
                const time = Date.now() * 0.005;
                const flap = Math.sin(time) * 0.15;
                
                // Both Ï€ accuracy and Collatz properties affect wing flapping
                const accuracyMultiplier = 1 + (process.piAccuracy || 0) / 200;
                const collatzMultiplier = 1 + (process.collatzSteps || 0) / 300;
                const hybridMultiplier = (accuracyMultiplier + collatzMultiplier) / 2;
                const enhancedFlap = flap * hybridMultiplier;
                
                this.ctx.save();
                this.ctx.globalAlpha = alpha;
                this.ctx.translate(x, y);
                
                // Draw left wing with Ï€ symbol
                this.ctx.fillStyle = color;
                this.ctx.beginPath();
                this.ctx.ellipse(-wingSize * 0.3, -wingSize * 0.2, wingSize * 0.4, wingSize * 0.3, enhancedFlap, 0, 2 * Math.PI);
                this.ctx.fill();
                
                // Draw right wing with Collatz symbol (3n+1)
                this.ctx.beginPath();
                this.ctx.ellipse(wingSize * 0.3, -wingSize * 0.2, wingSize * 0.4, wingSize * 0.3, -enhancedFlap, 0, 2 * Math.PI);
                this.ctx.fill();
                
                // Draw body
                this.ctx.fillStyle = color.replace('0.8', '1.0').replace('0.6', '0.8').replace('0.4', '0.6');
                this.ctx.beginPath();
                this.ctx.ellipse(0, 0, bodySize * 0.2, bodySize, 0, 0, 2 * Math.PI);
                this.ctx.fill();
                
                // Draw hybrid symbol on body (Ï€ + C)
                this.ctx.fillStyle = 'white';
                this.ctx.font = `${bodySize * 0.6}px Arial`;
                this.ctx.textAlign = 'center';
                this.ctx.fillText('Ï€C', 0, bodySize * 0.3);
                
                this.ctx.restore();
            }
            
            drawTraditionalProcesses() {
                for (const [id, process] of this.processes) {
                    const alpha = process.state === 'dying' ? 0.3 : 1.0;
                    const size = this.processRadius * 2;
                    
                    // Draw butterfly process
                    this.drawButterflyProcess(process.x, process.y, size, alpha, process.state);
                    
                    // Draw process ID
                    this.ctx.fillStyle = 'white';
                    this.ctx.font = 'bold 10px Arial';
                    this.ctx.globalAlpha = alpha;
                    this.ctx.fillText(process.id.toString(), process.x, process.y);
                    
                    // Draw depth indicator
                    this.ctx.fillStyle = '#333';
                    this.ctx.font = '8px Arial';
                    this.ctx.fillText(`d:${process.depth}`, process.x, process.y + 25);
                    
                    this.ctx.globalAlpha = 1.0;
                }
            }
            
            // Ï€-Solving Vampire Process Drawing
            drawPiProcesses() {
                for (const [id, process] of this.processes) {
                    const alpha = process.state === 'dying' ? 0.3 : 1.0;
                    const size = this.processRadius * 2;
                    
                    // Color based on Ï€ calculation method and accuracy
                    const methodColors = {
                        'monteCarlo': [255, 100, 100],
                        'buffonNeedle': [100, 255, 100],
                        'infiniteSeries': [100, 100, 255],
                        'goldenRatio': [255, 255, 100],
                        'mandelbrot': [255, 100, 255],
                        'ramanujan': [100, 255, 255],
                        'chudnovsky': [255, 150, 100],
                        'machin': [150, 255, 150],
                        'gaussLegendre': [150, 150, 255]
                    };
                    
                    const baseColor = methodColors[process.piMethod] || [255, 100, 100];
                    const accuracy = process.piAccuracy || 0;
                    
                    // Adjust color intensity based on Ï€ accuracy
                    const colorIntensity = 0.5 + (accuracy / 100) * 0.5;
                    const color = `rgba(${baseColor[0] * colorIntensity}, ${baseColor[1] * colorIntensity}, ${baseColor[2] * colorIntensity}, ${alpha})`;
                    
                    // Draw Ï€-solving butterfly process
                    this.drawPiButterflyProcess(process.x, process.y, size, alpha, process.state, color, process);
                    
                    // Draw Ï€ value and accuracy
                    this.ctx.fillStyle = 'white';
                    this.ctx.font = 'bold 8px Arial';
                    this.ctx.globalAlpha = alpha;
                    this.ctx.textAlign = 'center';
                    
                    // Show Ï€ value (truncated)
                    const piDisplay = process.piValue ? process.piValue.toFixed(4) : '0.0000';
                    this.ctx.fillText(piDisplay, process.x, process.y - 15);
                    
                    // Show accuracy percentage
                    const accuracyDisplay = `${Math.round(process.piAccuracy || 0)}%`;
                    this.ctx.fillText(accuracyDisplay, process.x, process.y + 15);
                    
                    // Draw method indicator
                    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    this.ctx.font = '6px Arial';
                    this.ctx.fillText(process.piMethod?.substring(0, 4) || 'N/A', process.x, process.y + 25);
                    
                    this.ctx.globalAlpha = 1.0;
                }
            }
            
            drawPiButterflyProcess(x, y, size, alpha, state, color, process) {
                const wingSize = size * 0.8;
                const bodySize = size * 0.4;
                const time = Date.now() * 0.005;
                const flap = Math.sin(time) * 0.15;
                
                // Ï€ accuracy affects wing flapping speed
                const accuracyMultiplier = 1 + (process.piAccuracy || 0) / 200;
                const enhancedFlap = flap * accuracyMultiplier;
                
                this.ctx.save();
                this.ctx.globalAlpha = alpha;
                this.ctx.translate(x, y);
                
                // Draw left wing
                this.ctx.fillStyle = color;
                this.ctx.beginPath();
                this.ctx.ellipse(-wingSize * 0.3, -wingSize * 0.2, wingSize * 0.4, wingSize * 0.3, enhancedFlap, 0, 2 * Math.PI);
                this.ctx.fill();
                
                // Draw right wing
                this.ctx.beginPath();
                this.ctx.ellipse(wingSize * 0.3, -wingSize * 0.2, wingSize * 0.4, wingSize * 0.3, -enhancedFlap, 0, 2 * Math.PI);
                this.ctx.fill();
                
                // Draw body
                this.ctx.fillStyle = color.replace('0.8', '1.0').replace('0.6', '0.8').replace('0.4', '0.6');
                this.ctx.beginPath();
                this.ctx.ellipse(0, 0, bodySize * 0.2, bodySize, 0, 0, 2 * Math.PI);
                this.ctx.fill();
                
                // Draw Ï€ symbol on body
                this.ctx.fillStyle = 'white';
                this.ctx.font = `${bodySize * 0.8}px Arial`;
                this.ctx.textAlign = 'center';
                this.ctx.fillText('Ï€', 0, bodySize * 0.3);
                
                this.ctx.restore();
            }
            
            drawButterflyProcess(x, y, size, alpha, state) {
                const wingSize = size * 0.8;
                const bodySize = size * 0.4;
                const time = Date.now() * 0.005;
                const flap = Math.sin(time) * 0.15;
                
                // State-based colors
                let wingColor, detailColor;
                switch(state) {
                    case 'spawning':
                        wingColor = `rgba(255, 102, 102, ${alpha})`;
                        detailColor = `rgba(255, 150, 150, ${alpha * 0.7})`;
                        break;
                    case 'dying':
                        wingColor = `rgba(255, 170, 170, ${alpha})`;
                        detailColor = `rgba(255, 200, 200, ${alpha * 0.7})`;
                        break;
                    default:
                        wingColor = `rgba(255, 68, 68, ${alpha})`;
                        detailColor = `rgba(255, 102, 102, ${alpha * 0.7})`;
                }
                
                this.ctx.save();
                this.ctx.globalAlpha = alpha;
                this.ctx.translate(x, y);
                
                // Add pulsing effect for active processes
                if (state === 'active') {
                    const pulse = 1 + Math.sin(time * 2) * 0.1;
                    this.ctx.scale(pulse, pulse);
                }
                
                // Draw left wing
                this.ctx.fillStyle = wingColor;
                this.ctx.beginPath();
                this.ctx.ellipse(-wingSize/3, -wingSize/4 + flap, wingSize/2, wingSize/3, -0.3, 0, 2 * Math.PI);
                this.ctx.fill();
                
                // Draw right wing
                this.ctx.beginPath();
                this.ctx.ellipse(wingSize/3, -wingSize/4 - flap, wingSize/2, wingSize/3, 0.3, 0, 2 * Math.PI);
                this.ctx.fill();
                
                // Draw body
                this.ctx.fillStyle = `rgba(51, 51, 51, ${alpha})`;
                this.ctx.beginPath();
                this.ctx.ellipse(0, 0, bodySize/4, bodySize, 0, 0, 2 * Math.PI);
                this.ctx.fill();
                
                // Add wing details
                this.ctx.fillStyle = detailColor;
                this.ctx.beginPath();
                this.ctx.ellipse(-wingSize/3, -wingSize/4 + flap, wingSize/4, wingSize/6, -0.3, 0, 2 * Math.PI);
                this.ctx.fill();
                
                this.ctx.beginPath();
                this.ctx.ellipse(wingSize/3, -wingSize/4 - flap, wingSize/4, wingSize/6, 0.3, 0, 2 * Math.PI);
                this.ctx.fill();
                
                // Add antennae for spawning processes
                if (state === 'spawning') {
                    this.ctx.strokeStyle = `rgba(51, 51, 51, ${alpha})`;
                    this.ctx.lineWidth = 1;
                    this.ctx.beginPath();
                    this.ctx.moveTo(-2, -bodySize/2);
                    this.ctx.lineTo(-4, -bodySize/2 - 3);
                    this.ctx.moveTo(2, -bodySize/2);
                    this.ctx.lineTo(4, -bodySize/2 - 3);
                    this.ctx.stroke();
                }
                
                this.ctx.restore();
            }
            
            drawInfo() {
                // Draw title
                this.ctx.fillStyle = '#333';
                this.ctx.font = 'bold 16px Arial';
                this.ctx.textAlign = 'left';
                this.ctx.fillText('Vampire Process Visualization', 20, 30);
                
                // Draw status
                this.ctx.fillStyle = this.isRunning ? '#ff4444' : '#666';
                this.ctx.font = '12px Arial';
                this.ctx.fillText(this.isRunning ? 'RUNNING' : 'STOPPED', 20, 50);
            }
            
            updateStats() {
                document.getElementById('activeProcesses').textContent = this.activeProcesses.size;
                document.getElementById('totalEvents').textContent = this.events.length;
                document.getElementById('frameCount').textContent = this.frameCount;
                document.getElementById('processDepth').textContent = this.maxDepth;
            }
            
            takeSnapshot() {
                const link = document.createElement('a');
                link.download = `vampire_process_${Date.now()}.png`;
                link.href = this.canvas.toDataURL();
                link.click();
            }
            
            // Ï€ Calculation Methods
            calculatePiAllMethods() {
                if (this.piCalculations.isCalculating) return;
                
                this.piCalculations.isCalculating = true;
                
                // Calculate Ï€ using all chaos methods
                this.piCalculations.monteCarlo = this.chaosMath.calculatePiMonteCarlo(this.piCalculations.iterations);
                this.piCalculations.buffonNeedle = this.chaosMath.calculatePiBuffonNeedle(1, 2, this.piCalculations.iterations);
                this.piCalculations.infiniteSeries = this.chaosMath.calculatePiInfiniteSeries(Math.min(this.piCalculations.iterations, 1000));
                this.piCalculations.goldenRatio = this.chaosMath.calculatePiGoldenRatio(this.piCalculations.iterations);
                this.piCalculations.mandelbrot = this.chaosMath.calculatePiMandelbrot(this.piCalculations.iterations);
                
                // Calculate Ï€ using rapid convergence methods
                this.piCalculations.ramanujan = this.chaosMath.calculatePiRamanujan(Math.min(this.piCalculations.iterations / 100, 10));
                this.piCalculations.chudnovsky = this.chaosMath.calculatePiChudnovsky(Math.min(this.piCalculations.iterations / 100, 10));
                this.piCalculations.machin = this.chaosMath.calculatePiMachin(Math.min(this.piCalculations.iterations / 50, 20));
                this.piCalculations.gaussLegendre = this.chaosMath.calculatePiGaussLegendre(Math.min(this.piCalculations.iterations / 100, 10));
                this.piCalculations.borweinQuartic = this.chaosMath.calculatePiBorweinQuartic(Math.min(this.piCalculations.iterations / 100, 10));
                
                // Calculate combined result including all methods
                const allMethods = [
                    this.piCalculations.monteCarlo,
                    this.piCalculations.buffonNeedle,
                    this.piCalculations.infiniteSeries,
                    this.piCalculations.goldenRatio,
                    this.piCalculations.mandelbrot,
                    this.piCalculations.ramanujan,
                    this.piCalculations.chudnovsky,
                    this.piCalculations.machin,
                    this.piCalculations.gaussLegendre,
                    this.piCalculations.borweinQuartic
                ];
                const validMethods = allMethods.filter(m => m > 0 && m < 10);
                this.piCalculations.combined = validMethods.length > 0 ? 
                    validMethods.reduce((sum, val) => sum + val, 0) / validMethods.length : 
                    Math.PI;
                
                this.piCalculations.isCalculating = false;
                this.updatePiDisplay();
            }
            
            updatePiDisplay() {
                // Update Ï€ display elements if they exist
                const piElements = {
                    'monteCarloPi': this.piCalculations.monteCarlo,
                    'buffonPi': this.piCalculations.buffonNeedle,
                    'seriesPi': this.piCalculations.infiniteSeries,
                    'goldenPi': this.piCalculations.goldenRatio,
                    'mandelbrotPi': this.piCalculations.mandelbrot,
                    'ramanujanPi': this.piCalculations.ramanujan,
                    'chudnovskyPi': this.piCalculations.chudnovsky,
                    'machinPi': this.piCalculations.machin,
                    'gaussLegendrePi': this.piCalculations.gaussLegendre,
                    'borweinQuarticPi': this.piCalculations.borweinQuartic,
                    'combinedPi': this.piCalculations.combined,
                    'actualPi': this.piCalculations.actualPi
                };
                
                for (const [id, value] of Object.entries(piElements)) {
                    const element = document.getElementById(id);
                    if (element) {
                        element.textContent = value.toFixed(6);
                    }
                }
            }
            
            // Rapid Convergence Ï€ Calculation Methods
            calculatePiRapidMethods() {
                if (this.piCalculations.isCalculating) return;
                
                this.piCalculations.isCalculating = true;
                
                // Calculate Ï€ using rapid convergence methods only
                this.piCalculations.ramanujan = this.chaosMath.calculatePiRamanujan(Math.min(this.piCalculations.iterations / 100, 10));
                this.piCalculations.chudnovsky = this.chaosMath.calculatePiChudnovsky(Math.min(this.piCalculations.iterations / 100, 10));
                this.piCalculations.machin = this.chaosMath.calculatePiMachin(Math.min(this.piCalculations.iterations / 50, 20));
                this.piCalculations.gaussLegendre = this.chaosMath.calculatePiGaussLegendre(Math.min(this.piCalculations.iterations / 100, 10));
                this.piCalculations.borweinQuartic = this.chaosMath.calculatePiBorweinQuartic(Math.min(this.piCalculations.iterations / 100, 10));
                
                // Calculate combined result for rapid methods only
                const rapidMethods = [
                    this.piCalculations.ramanujan,
                    this.piCalculations.chudnovsky,
                    this.piCalculations.machin,
                    this.piCalculations.gaussLegendre,
                    this.piCalculations.borweinQuartic
                ];
                const validRapidMethods = rapidMethods.filter(m => m > 0 && m < 10);
                this.piCalculations.combined = validRapidMethods.length > 0 ? 
                    validRapidMethods.reduce((sum, val) => sum + val, 0) / validRapidMethods.length : 
                    Math.PI;
                
                this.piCalculations.isCalculating = false;
                this.updatePiDisplay();
            }
            
            drawPiVisualization() {
                if (!this.piCalculations.isCalculating) return;
                
                // Draw Ï€ calculation visualization
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                this.ctx.font = 'bold 16px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('Calculating Ï€...', this.canvasWidth / 2, 50);
                
                // Draw progress indicator
                const progress = (Date.now() % 2000) / 2000;
                this.ctx.strokeStyle = '#ff4444';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                this.ctx.arc(this.canvasWidth / 2, 80, 20, 0, progress * 2 * Math.PI);
                this.ctx.stroke();
            }
            
            // Infinite Ï€ Calculation Methods
            startInfinitePiCalculation() {
                if (this.piCalculations.infiniteMode) return;
                
                this.piCalculations.infiniteMode = true;
                this.piCalculations.infiniteIterations = 0;
                this.piCalculations.convergenceHistory = [];
                this.piCalculations.bestAccuracy = 0;
                
                // Initialize tracking variables
                this.piCalculations.monteCarloPrevious = 0;
                this.piCalculations.buffonPrevious = { crossings: 0, result: 0 };
                this.piCalculations.seriesPrevious = 0;
                this.piCalculations.goldenPrevious = 0;
                
                this.runInfinitePiLoop();
            }
            
            stopInfinitePiCalculation() {
                this.piCalculations.infiniteMode = false;
                if (this.piCalculations.animationId) {
                    cancelAnimationFrame(this.piCalculations.animationId);
                    this.piCalculations.animationId = null;
                }
            }
            
            runInfinitePiLoop() {
                if (!this.piCalculations.infiniteMode) return;
                
                // Run one iteration of each infinite method
                this.piCalculations.infiniteIterations++;
                
                // Monte Carlo infinite
                this.piCalculations.monteCarlo = this.chaosMath.calculatePiMonteCarloInfinite(
                    this.piCalculations.infiniteIterations * 1000,
                    this.piCalculations.monteCarloPrevious
                );
                this.piCalculations.monteCarloPrevious = this.piCalculations.monteCarlo;
                
                // Buffon's Needle infinite
                this.piCalculations.buffonNeedle = this.chaosMath.calculatePiBuffonInfinite(
                    this.piCalculations.infiniteIterations * 1000,
                    this.piCalculations.buffonPrevious.crossings,
                    this.piCalculations.buffonPrevious.result
                );
                this.piCalculations.buffonPrevious.result = this.piCalculations.buffonNeedle;
                
                // Infinite Series
                this.piCalculations.infiniteSeries = this.chaosMath.calculatePiInfiniteSeriesInfinite(
                    this.piCalculations.infiniteIterations * 100,
                    this.piCalculations.seriesPrevious
                );
                this.piCalculations.seriesPrevious = this.piCalculations.infiniteSeries;
                
                // Golden Ratio infinite
                this.piCalculations.goldenRatio = this.chaosMath.calculatePiGoldenRatioInfinite(
                    this.piCalculations.infiniteIterations * 100,
                    this.piCalculations.goldenPrevious
                );
                this.piCalculations.goldenPrevious = this.piCalculations.goldenRatio;
                
                // Calculate combined result
                const methods = [
                    this.piCalculations.monteCarlo,
                    this.piCalculations.buffonNeedle,
                    this.piCalculations.infiniteSeries,
                    this.piCalculations.goldenRatio
                ];
                const validMethods = methods.filter(m => m > 0 && m < 10);
                this.piCalculations.combined = validMethods.length > 0 ? 
                    validMethods.reduce((sum, val) => sum + val, 0) / validMethods.length : 
                    Math.PI;
                
                // Track convergence
                const accuracy = this.chaosMath.calculateAccuracy(this.piCalculations.combined);
                this.piCalculations.bestAccuracy = Math.max(this.piCalculations.bestAccuracy, accuracy);
                
                this.piCalculations.convergenceHistory.push({
                    iteration: this.piCalculations.infiniteIterations,
                    combined: this.piCalculations.combined,
                    accuracy: accuracy,
                    timestamp: Date.now()
                });
                
                // Keep only last 1000 points for performance
                if (this.piCalculations.convergenceHistory.length > 1000) {
                    this.piCalculations.convergenceHistory = this.piCalculations.convergenceHistory.slice(-1000);
                }
                
                // Update display
                this.updatePiDisplay();
                
                // Continue infinite loop
                this.piCalculations.animationId = requestAnimationFrame(() => this.runInfinitePiLoop());
            }
            
            drawInfinitePiVisualization() {
                if (!this.piCalculations.infiniteMode) return;
                
                // Draw convergence graph
                this.drawConvergenceGraph();
                
                // Draw current status
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                this.ctx.font = 'bold 14px Arial';
                this.ctx.textAlign = 'left';
                this.ctx.fillText(`Infinite Ï€ Calculation`, 20, 30);
                this.ctx.fillText(`Iterations: ${this.piCalculations.infiniteIterations.toLocaleString()}`, 20, 50);
                this.ctx.fillText(`Best Accuracy: ${this.piCalculations.bestAccuracy.toFixed(4)}%`, 20, 70);
                this.ctx.fillText(`Current Ï€: ${this.piCalculations.combined.toFixed(8)}`, 20, 90);
                this.ctx.fillText(`Actual Ï€: ${Math.PI.toFixed(8)}`, 20, 110);
            }
            
            drawConvergenceGraph() {
                if (this.piCalculations.convergenceHistory.length < 2) return;
                
                const graphWidth = 400;
                const graphHeight = 200;
                const graphX = this.canvasWidth - graphWidth - 20;
                const graphY = 20;
                
                // Draw graph background
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                this.ctx.fillRect(graphX, graphY, graphWidth, graphHeight);
                
                // Draw Ï€ line
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                const piY = graphY + graphHeight - (Math.PI - 2.5) / (4.5 - 2.5) * graphHeight;
                this.ctx.moveTo(graphX, piY);
                this.ctx.lineTo(graphX + graphWidth, piY);
                this.ctx.stroke();
                
                // Draw convergence curve
                this.ctx.strokeStyle = '#ff4444';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                
                const history = this.piCalculations.convergenceHistory;
                const maxIterations = Math.max(...history.map(h => h.iteration));
                const minIterations = Math.min(...history.map(h => h.iteration));
                const iterationRange = maxIterations - minIterations;
                
                let firstPoint = true;
                for (const point of history) {
                    const x = graphX + ((point.iteration - minIterations) / iterationRange) * graphWidth;
                    const y = graphY + graphHeight - ((point.combined - 2.5) / (4.5 - 2.5)) * graphHeight;
                    
                    if (firstPoint) {
                        this.ctx.moveTo(x, y);
                        firstPoint = false;
                    } else {
                        this.ctx.lineTo(x, y);
                    }
                }
                this.ctx.stroke();
                
                // Draw accuracy curve
                this.ctx.strokeStyle = '#44ff44';
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                
                firstPoint = true;
                for (const point of history) {
                    const x = graphX + ((point.iteration - minIterations) / iterationRange) * graphWidth;
                    const y = graphY + graphHeight - (point.accuracy / 100) * graphHeight;
                    
                    if (firstPoint) {
                        this.ctx.moveTo(x, y);
                        firstPoint = false;
                    } else {
                        this.ctx.lineTo(x, y);
                    }
                }
                this.ctx.stroke();
            }
            
            // Collatz Conjecture Methods
            calculateCollatzSequence(startValue) {
                if (this.collatzCalculations.isCalculating) return;
                
                this.collatzCalculations.isCalculating = true;
                this.collatzCalculations.currentStartValue = startValue;
                
                const result = this.chaosMath.calculateCollatzSequence(startValue, 10000);
                this.collatzCalculations.currentSequence = result.sequence;
                this.collatzCalculations.maxSteps = Math.max(this.collatzCalculations.maxSteps, result.steps);
                this.collatzCalculations.maxValue = Math.max(this.collatzCalculations.maxValue, result.maxValue);
                this.collatzCalculations.totalSequences++;
                
                this.collatzCalculations.isCalculating = false;
                this.updateCollatzDisplay();
            }
            
            calculateCollatzChaos(startValue) {
                if (this.collatzCalculations.isCalculating) return;
                
                this.collatzCalculations.isCalculating = true;
                this.collatzCalculations.currentStartValue = startValue;
                
                const result = this.chaosMath.calculateCollatzChaos(startValue, 10000);
                this.collatzCalculations.currentSequence = result.sequence;
                this.collatzCalculations.chaosPoints = result.chaosPoints;
                this.collatzCalculations.maxSteps = Math.max(this.collatzCalculations.maxSteps, result.steps);
                this.collatzCalculations.maxValue = Math.max(this.collatzCalculations.maxValue, result.maxValue);
                this.collatzCalculations.totalSequences++;
                
                this.collatzCalculations.isCalculating = false;
                this.updateCollatzDisplay();
            }
            
            calculateCollatzStatistics(startRange, endRange) {
                if (this.collatzCalculations.isCalculating) return;
                
                this.collatzCalculations.isCalculating = true;
                
                const statistics = this.chaosMath.calculateCollatzStatistics(startRange, endRange);
                this.collatzCalculations.statistics = statistics;
                
                this.collatzCalculations.isCalculating = false;
                this.updateCollatzDisplay();
            }
            
            calculateCollatzTree(maxDepth) {
                if (this.collatzCalculations.isCalculating) return;
                
                this.collatzCalculations.isCalculating = true;
                
                const tree = this.chaosMath.calculateCollatzTree(maxDepth, 1000);
                this.collatzCalculations.tree = tree;
                
                this.collatzCalculations.isCalculating = false;
                this.updateCollatzDisplay();
            }
            
            calculateCollatzLorenz(startValue) {
                if (this.collatzCalculations.isCalculating) return;
                
                this.collatzCalculations.isCalculating = true;
                
                const hybrid = this.chaosMath.calculateCollatzLorenz(startValue, 1000);
                this.collatzCalculations.lorenzHybrid = hybrid;
                
                this.collatzCalculations.isCalculating = false;
                this.updateCollatzDisplay();
            }
            
            updateCollatzDisplay() {
                // Update Collatz display elements if they exist
                const collatzElements = {
                    'collatzStartValue': this.collatzCalculations.currentStartValue,
                    'collatzSteps': this.collatzCalculations.currentSequence.length - 1,
                    'collatzMaxValue': this.collatzCalculations.maxValue,
                    'collatzTotalSequences': this.collatzCalculations.totalSequences,
                    'collatzMaxSteps': this.collatzCalculations.maxSteps
                };
                
                for (const [id, value] of Object.entries(collatzElements)) {
                    const element = document.getElementById(id);
                    if (element) {
                        element.textContent = value.toString();
                    }
                }
            }
            
            drawCollatzVisualization() {
                if (!this.collatzCalculations.currentSequence.length) return;
                
                // Draw Collatz sequence visualization
                this.drawCollatzSequence();
                
                // Draw chaos points if available
                if (this.collatzCalculations.chaosPoints.length) {
                    this.drawCollatzChaos();
                }
                
                // Draw Lorenz hybrid if available
                if (this.collatzCalculations.lorenzHybrid) {
                    this.drawCollatzLorenz();
                }
            }
            
            drawCollatzSequence() {
                const sequence = this.collatzCalculations.currentSequence;
                if (sequence.length < 2) return;
                
                const startX = 50;
                const startY = this.canvasHeight - 100;
                const stepWidth = (this.canvasWidth - 100) / Math.min(sequence.length, 50);
                
                this.ctx.strokeStyle = '#ff4444';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                
                let firstPoint = true;
                for (let i = 0; i < Math.min(sequence.length, 50); i++) {
                    const x = startX + i * stepWidth;
                    const y = startY - (sequence[i] / this.collatzCalculations.maxValue) * 80;
                    
                    if (firstPoint) {
                        this.ctx.moveTo(x, y);
                        firstPoint = false;
                    } else {
                        this.ctx.lineTo(x, y);
                    }
                }
                this.ctx.stroke();
                
                // Draw sequence values
                this.ctx.fillStyle = '#ffffff';
                this.ctx.font = '10px Arial';
                this.ctx.textAlign = 'center';
                for (let i = 0; i < Math.min(sequence.length, 20); i += 2) {
                    const x = startX + i * stepWidth;
                    const y = startY - (sequence[i] / this.collatzCalculations.maxValue) * 80 - 10;
                    this.ctx.fillText(sequence[i].toString(), x, y);
                }
            }
            
            drawCollatzChaos() {
                const chaosPoints = this.collatzCalculations.chaosPoints;
                if (!chaosPoints.length) return;
                
                const centerX = this.canvasWidth / 2;
                const centerY = this.canvasHeight / 2;
                
                this.ctx.strokeStyle = 'rgba(255, 68, 68, 0.6)';
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                
                let firstPoint = true;
                for (const point of chaosPoints) {
                    const x = centerX + point.x;
                    const y = centerY + point.y;
                    
                    if (firstPoint) {
                        this.ctx.moveTo(x, y);
                        firstPoint = false;
                    } else {
                        this.ctx.lineTo(x, y);
                    }
                }
                this.ctx.stroke();
                
                // Draw points
                for (const point of chaosPoints) {
                    const x = centerX + point.x;
                    const y = centerY + point.y;
                    const alpha = Math.min(point.step / chaosPoints.length, 1);
                    
                    this.ctx.fillStyle = `rgba(255, 68, 68, ${alpha})`;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, 2, 0, 2 * Math.PI);
                    this.ctx.fill();
                }
            }
            
            drawCollatzLorenz() {
                const hybrid = this.collatzCalculations.lorenzHybrid;
                if (!hybrid || !hybrid.lorenzPoints.length) return;
                
                const centerX = this.canvasWidth / 2;
                const centerY = this.canvasHeight / 2;
                
                this.ctx.strokeStyle = 'rgba(68, 255, 68, 0.6)';
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                
                let firstPoint = true;
                for (const point of hybrid.lorenzPoints) {
                    const x = centerX + point.x;
                    const y = centerY + point.y;
                    
                    if (firstPoint) {
                        this.ctx.moveTo(x, y);
                        firstPoint = false;
                    } else {
                        this.ctx.lineTo(x, y);
                    }
                }
                this.ctx.stroke();
            }
        }
        
        // Initialize the visualizer
        let visualizer;
        
        window.onload = function() {
            visualizer = new VampireProcessVisualizer();
        };
        
        // Control functions
        function startVampireProcess() {
            visualizer.startVampireProcess();
        }
        
        function stopVampireProcess() {
            visualizer.stopVampireProcess();
        }
        
        function clearVisualization() {
            visualizer.clearVisualization();
        }
        
        function takeSnapshot() {
            visualizer.takeSnapshot();
        }
        
        function toggleMouseFollowing() {
            visualizer.mouseFollowingEnabled = !visualizer.mouseFollowingEnabled;
            const btn = document.getElementById('followBtn');
            btn.textContent = visualizer.mouseFollowingEnabled ? 'Disable Mouse Following' : 'Enable Mouse Following';
            btn.style.background = visualizer.mouseFollowingEnabled ? 
                'linear-gradient(45deg, #ff4444, #cc0000)' : 
                'linear-gradient(45deg, #666, #444)';
        }
        
        function clearDrawing() {
            visualizer.clearDrawing();
        }
        
        function toggleBresenhamCircles() {
            visualizer.bresenhamCirclesEnabled = !visualizer.bresenhamCirclesEnabled;
            const btn = document.getElementById('bresenhamBtn');
            btn.textContent = visualizer.bresenhamCirclesEnabled ? 'Disable Bresenham Circles' : 'Enable Bresenham Circles';
            btn.style.background = visualizer.bresenhamCirclesEnabled ? 
                'linear-gradient(45deg, #ff4444, #cc0000)' : 
                'linear-gradient(45deg, #666, #444)';
        }

        function toggleSineWaves() {
            visualizer.sineWavesEnabled = !visualizer.sineWavesEnabled;
            const btn = document.getElementById('sineBtn');
            btn.textContent = visualizer.sineWavesEnabled ? 'Disable Sine Waves' : 'Enable Sine Waves';
            btn.style.background = visualizer.sineWavesEnabled ? 
                'linear-gradient(45deg, #ff4444, #cc0000)' : 
                'linear-gradient(45deg, #666, #444)';
        }
        
        function toggleChaosComponent(componentName) {
            visualizer.chaosMath.toggleComponent(componentName);
            const btn = document.getElementById(componentName + 'Btn');
            const isEnabled = visualizer.chaosMath.isComponentEnabled(componentName);
            
            // Update button text and style
            const componentNames = {
                'lorenzAttractor': 'Lorenz Attractor',
                'mandelbrotField': 'Mandelbrot Field', 
                'chaoticMovement': 'Chaotic Movement',
                'fractalBranches': 'Fractal Branches'
            };
            
            btn.textContent = isEnabled ? 
                `Disable ${componentNames[componentName]}` : 
                `Enable ${componentNames[componentName]}`;
            btn.style.background = isEnabled ? 
                'linear-gradient(45deg, #ff4444, #cc0000)' : 
                'linear-gradient(45deg, #666, #444)';
        }

        function toggleAudio() {
            visualizer.audioEnabled = !visualizer.audioEnabled;
            if (visualizer.audioEnabled) {
                visualizer.ensureAudio();
                if (visualizer.audioContext.state === 'suspended') {
                    visualizer.audioContext.resume();
                }
            } else if (visualizer.masterGain) {
                // Mute all voices quickly
                for (const v of visualizer.sineVoices) {
                    if (v && v.gain && v.gain.gain && visualizer.audioContext) {
                        v.gain.gain.setTargetAtTime(0.0, visualizer.audioContext.currentTime, 0.05);
                    }
                }
            }
            const btn = document.getElementById('audioBtn');
            btn.textContent = visualizer.audioEnabled ? 'Disable Audio' : 'Enable Audio';
            btn.style.background = visualizer.audioEnabled ? 
                'linear-gradient(45deg, #ff4444, #cc0000)' : 
                'linear-gradient(45deg, #666, #444)';
        }

        function setAudioVolume(val) {
            const v = Math.max(0, Math.min(1, parseFloat(val)));
            visualizer.audioVolume = v;
            if (visualizer.masterGain) {
                if (visualizer.masterGain.gain.setTargetAtTime && visualizer.audioContext) {
                    visualizer.masterGain.gain.setTargetAtTime(v, visualizer.audioContext.currentTime, 0.05);
                } else {
                    visualizer.masterGain.gain.value = v;
                }
            }
        }
        
        // Ï€ Calculation Functions
        function calculatePi() {
            visualizer.calculatePiAllMethods();
        }
        
        function clearPiCalculations() {
            visualizer.piCalculations.monteCarlo = 0;
            visualizer.piCalculations.buffonNeedle = 0;
            visualizer.piCalculations.infiniteSeries = 0;
            visualizer.piCalculations.goldenRatio = 0;
            visualizer.piCalculations.mandelbrot = 0;
            visualizer.piCalculations.ramanujan = 0;
            visualizer.piCalculations.chudnovsky = 0;
            visualizer.piCalculations.machin = 0;
            visualizer.piCalculations.gaussLegendre = 0;
            visualizer.piCalculations.borweinQuartic = 0;
            visualizer.piCalculations.combined = 0;
            visualizer.updatePiDisplay();
        }
        
        // Rapid Convergence Ï€ Functions
        function calculateRapidPi() {
            visualizer.calculatePiRapidMethods();
        }
        
        function clearRapidPi() {
            visualizer.piCalculations.ramanujan = 0;
            visualizer.piCalculations.chudnovsky = 0;
            visualizer.piCalculations.machin = 0;
            visualizer.piCalculations.gaussLegendre = 0;
            visualizer.piCalculations.borweinQuartic = 0;
            visualizer.piCalculations.combined = 0;
            visualizer.updatePiDisplay();
        }
        
        function updatePiIterations() {
            const slider = document.getElementById('piIterations');
            const count = document.getElementById('iterationCount');
            visualizer.piCalculations.iterations = parseInt(slider.value);
            count.textContent = slider.value;
        }
        
        // Infinite Ï€ Calculation Functions
        function startInfinitePi() {
            visualizer.startInfinitePiCalculation();
            
            // Update button states
            document.getElementById('startInfiniteBtn').disabled = true;
            document.getElementById('stopInfiniteBtn').disabled = false;
            document.getElementById('startInfiniteBtn').textContent = 'Running...';
        }
        
        function stopInfinitePi() {
            visualizer.stopInfinitePiCalculation();
            
            // Update button states
            document.getElementById('startInfiniteBtn').disabled = false;
            document.getElementById('stopInfiniteBtn').disabled = true;
            document.getElementById('startInfiniteBtn').textContent = 'Start Infinite Ï€';
        }
        
        function resetInfinitePi() {
            visualizer.stopInfinitePiCalculation();
            
            // Reset all values
            visualizer.piCalculations.infiniteIterations = 0;
            visualizer.piCalculations.convergenceHistory = [];
            visualizer.piCalculations.bestAccuracy = 0;
            visualizer.piCalculations.monteCarlo = 0;
            visualizer.piCalculations.buffonNeedle = 0;
            visualizer.piCalculations.infiniteSeries = 0;
            visualizer.piCalculations.goldenRatio = 0;
            visualizer.piCalculations.combined = 0;
            
            // Update display
            visualizer.updatePiDisplay();
            
            // Update button states
            document.getElementById('startInfiniteBtn').disabled = false;
            document.getElementById('stopInfiniteBtn').disabled = true;
            document.getElementById('startInfiniteBtn').textContent = 'Start Infinite Ï€';
        }
        
        // Collatz Conjecture Functions
        function calculateCollatz() {
            const startValue = parseInt(document.getElementById('collatzStartValue').value) || 27;
            visualizer.calculateCollatzSequence(startValue);
        }
        
        function calculateCollatzChaos() {
            const startValue = parseInt(document.getElementById('collatzStartValue').value) || 27;
            visualizer.calculateCollatzChaos(startValue);
        }
        
        function calculateCollatzStats() {
            visualizer.calculateCollatzStatistics(1, 1000);
        }
        
        function calculateCollatzTree() {
            visualizer.calculateCollatzTree(10);
        }
        
        function calculateCollatzLorenz() {
            const startValue = parseInt(document.getElementById('collatzStartValue').value) || 27;
            visualizer.calculateCollatzLorenz(startValue);
        }
        
        // Vampire Process Mode Functions
        function toggleCollatzVampire() {
            visualizer.hybridPiCollatzMode = false;
            visualizer.piVampireMode = false;
            visualizer.collatzVampireMode = true;
            document.getElementById('collatzVampireBtn').disabled = true;
            document.getElementById('traditionalVampireBtn').disabled = false;
            document.getElementById('piVampireBtn').disabled = false;
            document.getElementById('hybridPiCollatzBtn').disabled = false;
            document.getElementById('collatzVampireBtn').textContent = 'Collatz Vampire Active';
            document.getElementById('traditionalVampireBtn').textContent = 'Switch to Traditional';
            document.getElementById('piVampireBtn').textContent = 'Switch to Ï€';
            document.getElementById('hybridPiCollatzBtn').textContent = 'Switch to Hybrid';
        }
        
        function toggleTraditionalVampire() {
            visualizer.hybridPiCollatzMode = false;
            visualizer.piVampireMode = false;
            visualizer.collatzVampireMode = false;
            document.getElementById('traditionalVampireBtn').disabled = true;
            document.getElementById('collatzVampireBtn').disabled = false;
            document.getElementById('piVampireBtn').disabled = false;
            document.getElementById('hybridPiCollatzBtn').disabled = false;
            document.getElementById('traditionalVampireBtn').textContent = 'Traditional Vampire Active';
            document.getElementById('collatzVampireBtn').textContent = 'Switch to Collatz';
            document.getElementById('piVampireBtn').textContent = 'Switch to Ï€';
            document.getElementById('hybridPiCollatzBtn').textContent = 'Switch to Hybrid';
        }
        
        // Ï€ Vampire Mode Functions
        function togglePiVampire() {
            visualizer.hybridPiCollatzMode = false;
            visualizer.piVampireMode = true;
            visualizer.collatzVampireMode = false;
            document.getElementById('piVampireBtn').disabled = true;
            document.getElementById('collatzVampireBtn').disabled = false;
            document.getElementById('traditionalVampireBtn').disabled = false;
            document.getElementById('hybridPiCollatzBtn').disabled = false;
            document.getElementById('piVampireBtn').textContent = 'Ï€ Vampire Active';
            document.getElementById('collatzVampireBtn').textContent = 'Switch to Collatz';
            document.getElementById('traditionalVampireBtn').textContent = 'Switch to Traditional';
            document.getElementById('hybridPiCollatzBtn').textContent = 'Switch to Hybrid';
        }
        
        // Hybrid Ï€-Collatz Mode Functions
        function toggleHybridPiCollatz() {
            visualizer.hybridPiCollatzMode = true;
            visualizer.piVampireMode = false;
            visualizer.collatzVampireMode = false;
            document.getElementById('hybridPiCollatzBtn').disabled = true;
            document.getElementById('piVampireBtn').disabled = false;
            document.getElementById('collatzVampireBtn').disabled = false;
            document.getElementById('traditionalVampireBtn').disabled = false;
            document.getElementById('hybridPiCollatzBtn').textContent = 'Hybrid Ï€-Collatz Active';
            document.getElementById('piVampireBtn').textContent = 'Switch to Ï€';
            document.getElementById('collatzVampireBtn').textContent = 'Switch to Collatz';
            document.getElementById('traditionalVampireBtn').textContent = 'Switch to Traditional';
        }
        
        // Handle window resize
        window.addEventListener('resize', function() {
            if (visualizer) {
                visualizer.setupCanvas();
            }
        });
    </script>
</body>
</html>
