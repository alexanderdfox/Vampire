<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vampire Process Visualization</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #1e1e1e, #2d2d2d);
            color: white;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            text-align: center;
        }
        
        h1 {
            color: #ff4444;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            margin-bottom: 10px;
        }
        
        .subtitle {
            color: #cccccc;
            margin-bottom: 30px;
            font-size: 16px;
        }
        
        .canvas-container {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }
        
        canvas {
            border: 2px solid #333;
            border-radius: 8px;
            background: #f8f8f8;
            cursor: none; /* Hide default cursor */
        }
        
        .custom-cursor {
            position: absolute;
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, #ff4444, #cc0000);
            border-radius: 50%;
            pointer-events: none;
            z-index: 1000;
            box-shadow: 0 0 10px rgba(255, 68, 68, 0.8);
            transition: all 0.1s ease;
            border: 2px solid white;
        }
        
        .cursor-trail {
            position: absolute;
            width: 4px;
            height: 4px;
            background: rgba(255, 68, 68, 0.6);
            border-radius: 50%;
            pointer-events: none;
            z-index: 999;
        }
        
        .controls {
            margin: 20px 0;
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        button {
            background: linear-gradient(45deg, #ff4444, #cc0000);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(255, 68, 68, 0.3);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 68, 68, 0.4);
        }
        
        button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .stat-card {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #ff4444;
        }
        
        .stat-label {
            font-size: 14px;
            color: #cccccc;
            margin-top: 5px;
        }
        
        .info {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: left;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .info h3 {
            color: #ff4444;
            margin-top: 0;
        }
        
        .info ul {
            margin: 10px 0;
            padding-left: 20px;
        }
        
        .info li {
            margin: 5px 0;
            color: #cccccc;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸ§› Vampire Process Visualization</h1>
        <p class="subtitle">Real-time visualization of Vampire process behavior</p>
        
        <div class="canvas-container">
            <canvas id="vampireCanvas" width="1000" height="600"></canvas>
            <div id="customCursor" class="custom-cursor"></div>
        </div>
        
        <div class="controls">
            <button id="startBtn" onclick="startVampireProcess()">Start Vampire Process</button>
            <button id="stopBtn" onclick="stopVampireProcess()" disabled>Stop Process</button>
            <button id="clearBtn" onclick="clearVisualization()">Clear</button>
            <button id="clearDrawingBtn" onclick="clearDrawing()">Clear Drawing</button>
            <button id="snapshotBtn" onclick="takeSnapshot()">Take Snapshot</button>
            <button id="followBtn" onclick="toggleMouseFollowing()">Toggle Mouse Following</button>
        </div>
        
        <div class="stats">
            <div class="stat-card">
                <div class="stat-value" id="activeProcesses">0</div>
                <div class="stat-label">Active Processes</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="totalEvents">0</div>
                <div class="stat-label">Total Events</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="frameCount">0</div>
                <div class="stat-label">Frame Count</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="processDepth">0</div>
                <div class="stat-label">Max Depth</div>
            </div>
        </div>
        
        <div class="info">
            <h3>About the Vampire Process</h3>
            <p>This visualization shows the behavior of vampire.cpp:</p>
            <ul>
                <li><strong>Process Spawning:</strong> Each process spawns a child and immediately dies</li>
                <li><strong>Continuous Cycle:</strong> The child becomes the new parent, continuing the cycle</li>
                <li><strong>Real-time Visualization:</strong> Red circles represent active processes</li>
                <li><strong>Process Relationships:</strong> Arrows show parent-child connections</li>
                <li><strong>Live Statistics:</strong> Monitor active processes, events, and depth</li>
            </ul>
        </div>
    </div>

    <script>
        class VampireProcessVisualizer {
            constructor() {
                this.canvas = document.getElementById('vampireCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.customCursor = document.getElementById('customCursor');
                this.isRunning = false;
                this.frameCount = 0;
                this.processes = new Map();
                this.events = [];
                this.maxDepth = 0;
                this.animationId = null;
                
                // Process tracking
                this.processCounter = 0;
                this.activeProcesses = new Set();
                
                // Mouse following
                this.cursorTrails = [];
                this.maxTrails = 20;
                this.currentTargetProcess = null;
                this.cursorPosition = { x: 0, y: 0 };
                this.targetPosition = { x: 0, y: 0 };
                this.mouseFollowingEnabled = true;
                
                // Drawing functionality
                this.isDrawing = false;
                this.drawingPath = [];
                this.lastMousePos = { x: 0, y: 0 };
                
                // Visual settings
                this.canvasWidth = 1000;
                this.canvasHeight = 600;
                this.processRadius = 15;
                this.colors = {
                    active: '#ff4444',
                    spawning: '#ff6666',
                    dying: '#ffaaaa'
                };
                
                this.setupCanvas();
                this.setupMouseFollowing();
                this.startAnimation();
            }
            
            setupCanvas() {
                this.canvas.width = this.canvasWidth;
                this.canvas.height = this.canvasHeight;
                this.ctx.font = '12px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
            }
            
            setupMouseFollowing() {
                // Initialize cursor position
                this.cursorPosition.x = this.canvasWidth / 2;
                this.cursorPosition.y = this.canvasHeight / 2;
                this.targetPosition.x = this.cursorPosition.x;
                this.targetPosition.y = this.cursorPosition.y;
                
                // Position custom cursor
                this.updateCustomCursorPosition();
                
                // Add mouse move listener for manual control
                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.cursorPosition.x = e.clientX - rect.left;
                    this.cursorPosition.y = e.clientY - rect.top;
                    this.updateCustomCursorPosition();
                });
                
                // Add mouse event listeners for drawing
                this.canvas.addEventListener('mousedown', (e) => {
                    this.startDrawing(e);
                });
                
                this.canvas.addEventListener('mousemove', (e) => {
                    if (this.isDrawing) {
                        this.drawLine(e);
                    }
                });
                
                this.canvas.addEventListener('mouseup', (e) => {
                    this.stopDrawing();
                });
                
                this.canvas.addEventListener('mouseleave', (e) => {
                    this.stopDrawing();
                });
            }
            
            updateCustomCursorPosition() {
                const canvasRect = this.canvas.getBoundingClientRect();
                this.customCursor.style.left = (canvasRect.left + this.cursorPosition.x - 10) + 'px';
                this.customCursor.style.top = (canvasRect.top + this.cursorPosition.y - 10) + 'px';
            }
            
            startDrawing(e) {
                this.isDrawing = true;
                const rect = this.canvas.getBoundingClientRect();
                this.lastMousePos.x = e.clientX - rect.left;
                this.lastMousePos.y = e.clientY - rect.top;
                this.drawingPath = [this.lastMousePos];
            }
            
            drawLine(e) {
                if (!this.isDrawing) return;
                
                const rect = this.canvas.getBoundingClientRect();
                const currentPos = {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
                
                // Add point to drawing path
                this.drawingPath.push(currentPos);
                
                // Draw line segment immediately
                this.ctx.strokeStyle = 'black';
                this.ctx.lineWidth = 3;
                this.ctx.lineCap = 'round';
                this.ctx.beginPath();
                this.ctx.moveTo(this.lastMousePos.x, this.lastMousePos.y);
                this.ctx.lineTo(currentPos.x, currentPos.y);
                this.ctx.stroke();
                
                this.lastMousePos = currentPos;
            }
            
            stopDrawing() {
                this.isDrawing = false;
            }
            
            updateCursorTarget() {
                if (!this.isRunning || !this.mouseFollowingEnabled) return;
                
                // Find the most recently spawned process
                let newestProcess = null;
                let newestTime = 0;
                
                for (const [id, process] of this.processes) {
                    if (process.spawnTime > newestTime) {
                        newestTime = process.spawnTime;
                        newestProcess = process;
                    }
                }
                
                if (newestProcess) {
                    this.targetPosition.x = newestProcess.x;
                    this.targetPosition.y = newestProcess.y;
                }
            }
            
            updateCursorMovement() {
                // Smooth cursor movement towards target
                const speed = 0.1;
                this.cursorPosition.x += (this.targetPosition.x - this.cursorPosition.x) * speed;
                this.cursorPosition.y += (this.targetPosition.y - this.cursorPosition.y) * speed;
                
                // Add cursor trail
                this.cursorTrails.push({
                    x: this.cursorPosition.x,
                    y: this.cursorPosition.y,
                    life: 1.0
                });
                
                // Update trail life
                this.cursorTrails = this.cursorTrails.filter(trail => {
                    trail.life -= 0.05;
                    return trail.life > 0;
                });
                
                // Limit trail length
                if (this.cursorTrails.length > this.maxTrails) {
                    this.cursorTrails = this.cursorTrails.slice(-this.maxTrails);
                }
                
                this.updateCustomCursorPosition();
            }
            
            startAnimation() {
                const animate = () => {
                    this.update();
                    this.draw();
                    this.animationId = requestAnimationFrame(animate);
                };
                animate();
            }
            
            startVampireProcess() {
                if (this.isRunning) return;
                
                this.isRunning = true;
                this.processCounter = 0;
                this.events = [];
                this.maxDepth = 0;
                
                // Start the first vampire process
                this.spawnVampireProcess(0, 0);
                
                document.getElementById('startBtn').disabled = true;
                document.getElementById('stopBtn').disabled = false;
            }
            
            stopVampireProcess() {
                this.isRunning = false;
                document.getElementById('startBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
            }
            
            clearVisualization() {
                this.processes.clear();
                this.events = [];
                this.activeProcesses.clear();
                this.frameCount = 0;
                this.maxDepth = 0;
                this.processCounter = 0;
                this.cursorTrails = [];
                this.drawingPath = [];
                this.updateStats();
            }
            
            clearDrawing() {
                this.drawingPath = [];
            }
            
            spawnVampireProcess(parentId, depth) {
                if (!this.isRunning) return;
                
                const processId = ++this.processCounter;
                const x = Math.random() * (this.canvasWidth - 100) + 50;
                const y = Math.random() * (this.canvasHeight - 100) + 50;
                
                const process = {
                    id: processId,
                    parentId: parentId,
                    x: x,
                    y: y,
                    depth: depth,
                    state: 'spawning',
                    spawnTime: Date.now(),
                    lifeTime: 0
                };
                
                this.processes.set(processId, process);
                this.activeProcesses.add(processId);
                this.maxDepth = Math.max(this.maxDepth, depth);
                
                // Record the spawn event
                this.events.push({
                    type: 'spawn',
                    processId: processId,
                    parentId: parentId,
                    timestamp: Date.now(),
                    depth: depth
                });
                
                // Immediately spawn a child (vampire behavior)
                setTimeout(() => {
                    if (this.isRunning) {
                        this.spawnVampireProcess(processId, depth + 1);
                    }
                }, Math.random() * 100 + 50); // Random delay 50-150ms
                
                // Process dies after spawning (vampire behavior)
                setTimeout(() => {
                    this.killProcess(processId);
                }, Math.random() * 200 + 100); // Random lifetime 100-300ms
            }
            
            killProcess(processId) {
                const process = this.processes.get(processId);
                if (process) {
                    process.state = 'dying';
                    this.activeProcesses.delete(processId);
                    
                    // Record the death event
                    this.events.push({
                        type: 'death',
                        processId: processId,
                        timestamp: Date.now(),
                        depth: process.depth
                    });
                    
                    // Remove process after death animation
                    setTimeout(() => {
                        this.processes.delete(processId);
                    }, 500);
                }
            }
            
            update() {
                this.frameCount++;
                
                // Update process states
                for (const [id, process] of this.processes) {
                    process.lifeTime = Date.now() - process.spawnTime;
                    
                    if (process.state === 'spawning' && process.lifeTime > 50) {
                        process.state = 'active';
                    }
                }
                
                // Update cursor following
                this.updateCursorTarget();
                this.updateCursorMovement();
                
                this.updateStats();
            }
            
            draw() {
                // Clear canvas
                this.ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);
                
                // Draw grid
                this.drawGrid();
                
                // Draw cursor trail
                this.drawCursorTrail();
                
                // Draw process connections
                this.drawConnections();
                
                // Draw processes
                this.drawProcesses();
                
                // Draw black lines
                this.drawBlackLines();
                
                // Draw info
                this.drawInfo();
            }
            
            drawBlackLines() {
                if (this.drawingPath.length < 2) return;
                
                this.ctx.strokeStyle = 'black';
                this.ctx.lineWidth = 3;
                this.ctx.lineCap = 'round';
                this.ctx.beginPath();
                
                this.ctx.moveTo(this.drawingPath[0].x, this.drawingPath[0].y);
                for (let i = 1; i < this.drawingPath.length; i++) {
                    this.ctx.lineTo(this.drawingPath[i].x, this.drawingPath[i].y);
                }
                this.ctx.stroke();
            }
            
            drawGrid() {
                this.ctx.strokeStyle = '#e0e0e0';
                this.ctx.lineWidth = 1;
                
                // Vertical lines
                for (let x = 0; x <= this.canvasWidth; x += 50) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.canvasHeight);
                    this.ctx.stroke();
                }
                
                // Horizontal lines
                for (let y = 0; y <= this.canvasHeight; y += 50) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvasWidth, y);
                    this.ctx.stroke();
                }
            }
            
            drawCursorTrail() {
                // Draw cursor trail
                for (let i = 0; i < this.cursorTrails.length; i++) {
                    const trail = this.cursorTrails[i];
                    const alpha = trail.life;
                    const size = 4 * alpha;
                    
                    this.ctx.fillStyle = `rgba(255, 68, 68, ${alpha * 0.6})`;
                    this.ctx.beginPath();
                    this.ctx.arc(trail.x, trail.y, size, 0, 2 * Math.PI);
                    this.ctx.fill();
                }
                
                // Draw cursor position indicator
                this.ctx.fillStyle = 'rgba(255, 68, 68, 0.3)';
                this.ctx.beginPath();
                this.ctx.arc(this.cursorPosition.x, this.cursorPosition.y, 25, 0, 2 * Math.PI);
                this.ctx.fill();
                
                this.ctx.strokeStyle = '#ff4444';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.arc(this.cursorPosition.x, this.cursorPosition.y, 25, 0, 2 * Math.PI);
                this.ctx.stroke();
            }
            
            drawConnections() {
                this.ctx.strokeStyle = '#ff6666';
                this.ctx.lineWidth = 2;
                
                for (const event of this.events.slice(-50)) { // Show last 50 events
                    if (event.type === 'spawn' && event.parentId > 0) {
                        const parent = this.processes.get(event.parentId);
                        const child = this.processes.get(event.processId);
                        
                        if (parent && child) {
                            this.drawSineWaveConnection(parent, child);
                        }
                    }
                }
            }
            
            drawSineWaveConnection(parent, child) {
                const dx = child.x - parent.x;
                const dy = child.y - parent.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx);
                
                // Circle parameters
                const radius = 25 + Math.sin(Date.now() * 0.005) * 15; // Dynamic radius
                const phase = Date.now() * 0.006; // Moving phase for animation
                
                // Calculate midpoint
                const midX = (parent.x + child.x) / 2;
                const midY = (parent.y + child.y) / 2;
                
                // Draw complete circle pattern
                this.ctx.beginPath();
                this.ctx.strokeStyle = `rgba(255, 102, 102, ${0.8})`;
                
                const steps = 60; // Full circle needs more steps
                for (let i = 0; i <= steps; i++) {
                    const t = i / steps;
                    const circleAngle = 2 * Math.PI * t + phase; // Full 2Ï€ circle
                    
                    // Calculate circle position
                    const circleX = midX + radius * Math.cos(circleAngle);
                    const circleY = midY + radius * Math.sin(circleAngle);
                    
                    if (i === 0) {
                        this.ctx.moveTo(circleX, circleY);
                    } else {
                        this.ctx.lineTo(circleX, circleY);
                    }
                }
                this.ctx.stroke();
                
                // Draw animated arrow pointing to child
                const arrowAngle = Math.atan2(child.y - midY, child.x - midX);
                const arrowX = midX + radius * Math.cos(arrowAngle + phase);
                const arrowY = midY + radius * Math.sin(arrowAngle + phase);
                
                // Draw arrow pointing toward child
                const arrowLength = 20;
                this.ctx.strokeStyle = '#ff4444';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                this.ctx.moveTo(arrowX, arrowY);
                this.ctx.lineTo(
                    arrowX + arrowLength * Math.cos(arrowAngle),
                    arrowY + arrowLength * Math.sin(arrowAngle)
                );
                this.ctx.moveTo(arrowX, arrowY);
                this.ctx.lineTo(
                    arrowX + arrowLength * Math.cos(arrowAngle - Math.PI / 6),
                    arrowY + arrowLength * Math.sin(arrowAngle - Math.PI / 6)
                );
                this.ctx.moveTo(arrowX, arrowY);
                this.ctx.lineTo(
                    arrowX + arrowLength * Math.cos(arrowAngle + Math.PI / 6),
                    arrowY + arrowLength * Math.sin(arrowAngle + Math.PI / 6)
                );
                this.ctx.stroke();
                
                // Add pulsing effect to the arrow
                const pulseSize = 1 + Math.sin(Date.now() * 0.01) * 0.5;
                this.ctx.fillStyle = `rgba(255, 68, 68, ${0.6})`;
                this.ctx.beginPath();
                this.ctx.arc(arrowX, arrowY, 5 * pulseSize, 0, 2 * Math.PI);
                this.ctx.fill();
                
                // Add circle pattern indicator dots
                this.drawCirclePatternDots(midX, midY, radius, phase);
                
                // Draw connection lines from parent and child to circle
                this.drawConnectionLines(parent, child, midX, midY, radius, phase);
            }
            
            drawCirclePatternDots(midX, midY, radius, phase) {
                // Draw dots around the circle
                const dotSteps = 16;
                for (let i = 0; i < dotSteps; i++) {
                    const t = i / dotSteps;
                    const circleAngle = 2 * Math.PI * t + phase;
                    
                    const dotX = midX + radius * Math.cos(circleAngle);
                    const dotY = midY + radius * Math.sin(circleAngle);
                    
                    // Color dots based on circle phase
                    const dotAlpha = 0.3 + Math.sin(circleAngle) * 0.4;
                    const dotSize = 1.5 + Math.sin(circleAngle) * 1;
                    
                    this.ctx.fillStyle = `rgba(255, 200, 200, ${dotAlpha})`;
                    this.ctx.beginPath();
                    this.ctx.arc(dotX, dotY, dotSize, 0, 2 * Math.PI);
                    this.ctx.fill();
                }
            }
            
            drawConnectionLines(parent, child, midX, midY, radius, phase) {
                // Draw lines from parent and child to the circle
                this.ctx.strokeStyle = `rgba(255, 150, 150, ${0.6})`;
                this.ctx.lineWidth = 1;
                
                // Line from parent to circle
                const parentAngle = Math.atan2(parent.y - midY, parent.x - midX);
                const parentCircleX = midX + radius * Math.cos(parentAngle + phase);
                const parentCircleY = midY + radius * Math.sin(parentAngle + phase);
                
                this.ctx.beginPath();
                this.ctx.moveTo(parent.x, parent.y);
                this.ctx.lineTo(parentCircleX, parentCircleY);
                this.ctx.stroke();
                
                // Line from child to circle
                const childAngle = Math.atan2(child.y - midY, child.x - midX);
                const childCircleX = midX + radius * Math.cos(childAngle + phase);
                const childCircleY = midY + radius * Math.sin(childAngle + phase);
                
                this.ctx.beginPath();
                this.ctx.moveTo(child.x, child.y);
                this.ctx.lineTo(childCircleX, childCircleY);
                this.ctx.stroke();
            }
            
            drawProcesses() {
                for (const [id, process] of this.processes) {
                    const alpha = process.state === 'dying' ? 0.3 : 1.0;
                    const color = this.colors[process.state] || this.colors.active;
                    
                    // Draw process circle
                    this.ctx.fillStyle = color;
                    this.ctx.globalAlpha = alpha;
                    this.ctx.beginPath();
                    this.ctx.arc(process.x, process.y, this.processRadius, 0, 2 * Math.PI);
                    this.ctx.fill();
                    
                    // Draw process ID
                    this.ctx.fillStyle = 'white';
                    this.ctx.font = 'bold 10px Arial';
                    this.ctx.fillText(process.id.toString(), process.x, process.y);
                    
                    // Draw depth indicator
                    this.ctx.fillStyle = '#333';
                    this.ctx.font = '8px Arial';
                    this.ctx.fillText(`d:${process.depth}`, process.x, process.y + 20);
                    
                    this.ctx.globalAlpha = 1.0;
                }
            }
            
            drawInfo() {
                // Draw title
                this.ctx.fillStyle = '#333';
                this.ctx.font = 'bold 16px Arial';
                this.ctx.textAlign = 'left';
                this.ctx.fillText('Vampire Process Visualization', 20, 30);
                
                // Draw status
                this.ctx.fillStyle = this.isRunning ? '#ff4444' : '#666';
                this.ctx.font = '12px Arial';
                this.ctx.fillText(this.isRunning ? 'RUNNING' : 'STOPPED', 20, 50);
            }
            
            updateStats() {
                document.getElementById('activeProcesses').textContent = this.activeProcesses.size;
                document.getElementById('totalEvents').textContent = this.events.length;
                document.getElementById('frameCount').textContent = this.frameCount;
                document.getElementById('processDepth').textContent = this.maxDepth;
            }
            
            takeSnapshot() {
                const link = document.createElement('a');
                link.download = `vampire_process_${Date.now()}.png`;
                link.href = this.canvas.toDataURL();
                link.click();
            }
        }
        
        // Initialize the visualizer
        let visualizer;
        
        window.onload = function() {
            visualizer = new VampireProcessVisualizer();
        };
        
        // Control functions
        function startVampireProcess() {
            visualizer.startVampireProcess();
        }
        
        function stopVampireProcess() {
            visualizer.stopVampireProcess();
        }
        
        function clearVisualization() {
            visualizer.clearVisualization();
        }
        
        function takeSnapshot() {
            visualizer.takeSnapshot();
        }
        
        function toggleMouseFollowing() {
            visualizer.mouseFollowingEnabled = !visualizer.mouseFollowingEnabled;
            const btn = document.getElementById('followBtn');
            btn.textContent = visualizer.mouseFollowingEnabled ? 'Disable Mouse Following' : 'Enable Mouse Following';
            btn.style.background = visualizer.mouseFollowingEnabled ? 
                'linear-gradient(45deg, #ff4444, #cc0000)' : 
                'linear-gradient(45deg, #666, #444)';
        }
        
        function clearDrawing() {
            visualizer.clearDrawing();
        }
        
        // Handle window resize
        window.addEventListener('resize', function() {
            if (visualizer) {
                visualizer.setupCanvas();
            }
        });
    </script>
</body>
</html>
